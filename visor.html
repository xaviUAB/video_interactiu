<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualitzador Video Interactiu</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #000;
            color: #fff;
            margin: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
            font-family: sans-serif;
        }

        #player-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #000;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        .interactive-btn {
            position: absolute;
            transform: translate(-50%, -50%);
            cursor: pointer;
            border: none;
            outline: none;
            transition: transform 0.2s, opacity 0.5s; /* Fade in suau */
            z-index: 10;
            display: none; /* Ocult per defecte */
            opacity: 0;
            white-space: nowrap;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            /* Centrem text */
            align-items: center;
            justify-content: center;
        }

        .interactive-btn.visible {
            display: flex;
            opacity: 1;
        }

        .interactive-btn:hover {
            transform: translate(-50%, -50%) scale(1.05);
            z-index: 20;
        }

        /* Loading Spinner */
        .spinner {
            position: absolute;
            z-index: 50;
            border: 4px solid rgba(255, 255, 255, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #3b82f6;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #error-message {
            position: absolute;
            z-index: 60;
            display: none;
            text-align: center;
            color: #ef4444;
            background: rgba(0,0,0,0.8);
            padding: 2rem;
            border-radius: 8px;
        }

        /* FADE OVERLAY (Cortina negra) */
        .fade-overlay {
            position: absolute;
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background-color: black;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            z-index: 100;
        }
        
        .fade-overlay.active {
            opacity: 1;
            pointer-events: auto; /* Bloqueja clics mentre està negre */
        }

    </style>
</head>
<body>

    <div id="player-container">
        <div id="fade-overlay" class="fade-overlay"></div>
        <div id="loading" class="spinner"></div>
        <div id="error-message">
            <h2 class="text-xl font-bold mb-2">Error</h2>
            <p id="error-text"></p>
        </div>
        <!-- El contingut (video/iframe i botons) s'injectarà aquí via JS -->
    </div>

    <script>
        // CONFIGURACIÓ
        const JSON_FILE = 'project.json'; 
        
        // ESTAT
        let projectData = null;
        let currentNode = null;
        let clickedOptions = new Set(); // Per recordar opcions d'un sol ús
        let runtimeVariables = {};      // Estat de les variables

        // ELEMENTS DOM
        const container = document.getElementById('player-container');
        const loading = document.getElementById('loading');
        const errorDiv = document.getElementById('error-message');
        const errorText = document.getElementById('error-text');
        const fadeOverlay = document.getElementById('fade-overlay');

        // --- FUNCIONS AUXILIARS ---

        function hexToRgba(hex, alpha = 1) {
            let r = 0, g = 0, b = 0;
            if (!hex) return `rgba(0,0,0,${alpha})`;
            if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            } else if (hex.length === 7) {
                r = parseInt(hex[1] + hex[2], 16);
                g = parseInt(hex[3] + hex[4], 16);
                b = parseInt(hex[5] + hex[6], 16);
            }
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function getYoutubeId(url) {
            if (!url) return null;
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        function showError(msg) {
            loading.style.display = 'none';
            errorDiv.style.display = 'block';
            errorText.textContent = msg;
        }

        // --- LÒGICA DE VARIABLES I CONDICIONS ---

        function initVariables() {
            if (projectData.variables) {
                projectData.variables.forEach(v => {
                    runtimeVariables[v.name] = v.value;
                });
            }
        }

        function checkCondition(condition) {
            if (!condition || !condition.variable) return true;
            const currentVal = runtimeVariables[condition.variable];
            // Si la variable no existeix, assumim 0
            const safeCurrentVal = currentVal !== undefined ? currentVal : 0;
            const targetVal = parseFloat(condition.value);
            
            switch (condition.operator) {
                case 'eq': return safeCurrentVal == targetVal;
                case 'neq': return safeCurrentVal != targetVal;
                case 'gt': return safeCurrentVal > targetVal;
                case 'lt': return safeCurrentVal < targetVal;
                default: return true;
            }
        }

        function applyEffects(effects) {
            if (!effects) return;
            effects.forEach(eff => {
                if (!eff.variable) return;
                const currentVal = runtimeVariables[eff.variable] || 0;
                const effectVal = parseFloat(eff.value);

                if (eff.operator === 'set') runtimeVariables[eff.variable] = effectVal;
                if (eff.operator === 'add') runtimeVariables[eff.variable] = currentVal + effectVal;
                if (eff.operator === 'sub') runtimeVariables[eff.variable] = currentVal - effectVal;
            });
            console.log("Variables actualitzades:", runtimeVariables);
        }

        // --- NUCLI DEL REPRODUCTOR ---

        async function init() {
            try {
                const response = await fetch(JSON_FILE);
                if (!response.ok) throw new Error(`No s'ha pogut carregar ${JSON_FILE}`);
                projectData = await response.json();
                
                if (!projectData.nodes || projectData.nodes.length === 0) {
                    throw new Error("El fitxer JSON no conté escenes.");
                }

                initVariables();

                const startId = projectData.startNodeId || projectData.nodes[0].id;
                
                // Si el primer node té fade, comencem en negre
                const startNode = projectData.nodes.find(n => n.id === startId);
                if (startNode && startNode.transitionType === 'fade') {
                    fadeOverlay.classList.add('active');
                }

                loadNode(startId);

            } catch (err) {
                showError(err.message + ". Assegura't que 'project.json' està a la mateixa carpeta.");
            }
        }

        function loadNode(nodeId) {
            const node = projectData.nodes.find(n => n.id === nodeId);
            if (!node) {
                showError("Node no trobat: " + nodeId);
                return;
            }

            currentNode = node;
            renderScene(node);
        }

        function renderScene(node) {
            // Netejar contenidor d'elements antics (video, iframe, buttons)
            // Mantenim overlays i loaders
            const elementsToRemove = container.querySelectorAll('video, iframe, #buttons-layer');
            elementsToRemove.forEach(el => el.remove());

            loading.style.display = 'block';
            
            const youtubeId = getYoutubeId(node.videoUrl);

            // Callback quan el contingut està llest per mostrar-se
            const onContentReady = () => {
                loading.style.display = 'none';
                // Si és Fosa a Negre, retirem la cortina
                if (node.transitionType === 'fade') {
                    // Petita espera per assegurar que el render s'ha pintat
                    setTimeout(() => {
                        fadeOverlay.classList.remove('active');
                    }, 100);
                } else {
                    // Si no hi ha fosa, assegurar que no hi ha cortina
                    fadeOverlay.classList.remove('active');
                }
            };

            // 1. RENDERITZAR VIDEO / IFRAME
            if (youtubeId) {
                const iframe = document.createElement('iframe');
                iframe.src = `https://www.youtube.com/embed/${youtubeId}?rel=0&controls=0&autoplay=1&modestbranding=1`;
                iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
                iframe.allowFullscreen = true;
                iframe.onload = onContentReady;
                container.appendChild(iframe);
                
                // Per a YouTube, mostrem els botons directament
                renderButtons(node, true);

            } else {
                const video = document.createElement('video');
                // Assegurar ruta (si és blob o http es queda igual, si no es videos/)
                // En el visualitzador final, normalment serà videos/nom.mp4
                let src = node.videoUrl;
                if (!src.match(/^(http|https|blob):/) && !src.startsWith('videos/')) {
                     src = `videos/${src}`;
                }
                video.src = src;
                
                video.playsInline = true;
                video.autoplay = true;
                video.controls = false; 
                
                // Canplay s'activa quan hi ha prou dades
                video.oncanplay = onContentReady;
                
                video.onerror = (e) => {
                    loading.style.display = 'none';
                    const err = video.error;
                    let msg = "Error carregant el vídeo.";
                    if (err && err.code === 4) msg = `Vídeo no trobat: ${src}.`;
                    showError(msg);
                };

                video.ontimeupdate = () => checkButtonVisibility(video.currentTime);
                
                container.appendChild(video);
                
                renderButtons(node, false);
                
                video.play().catch(e => {
                    console.log("Autoplay bloquejat. Mostrant controls.");
                    video.controls = true; 
                    onContentReady(); // Forçar ready si autoplay falla
                });
            }
        }

        function renderButtons(node, isAlwaysVisible) {
            const buttonsContainer = document.createElement('div');
            buttonsContainer.id = 'buttons-layer';
            buttonsContainer.style.position = 'absolute';
            buttonsContainer.style.top = '0';
            buttonsContainer.style.left = '0';
            buttonsContainer.style.width = '100%';
            buttonsContainer.style.height = '100%';
            buttonsContainer.style.pointerEvents = 'none'; 

            node.options.forEach(opt => {
                // 1. Check Single Use
                if (opt.singleUse && clickedOptions.has(opt.id)) return;

                // 2. Check Condition (Variables)
                // A l'editor React ho fem en temps real, aquí ho fem en carregar l'escena.
                // Com que les variables només canvien al clicar (canvi d'escena), és segur fer-ho aquí.
                if (opt.condition && opt.condition.variable) {
                    if (!checkCondition(opt.condition)) return;
                }

                const btn = document.createElement('button');
                btn.className = 'interactive-btn';
                btn.textContent = opt.label;
                btn.dataset.id = opt.id;
                btn.dataset.startTime = opt.startTime;
                btn.dataset.endTime = opt.endTime || 99999;
                
                // Estils
                const s = opt.style;
                const bgColor = hexToRgba(s.backgroundColor, s.bgOpacity !== undefined ? s.bgOpacity : 1);
                
                btn.style.top = `${s.top}%`;
                btn.style.left = `${s.left}%`;
                btn.style.width = typeof s.width === 'number' ? `${s.width}px` : s.width;
                btn.style.height = typeof s.height === 'number' ? `${s.height}px` : s.height;
                btn.style.fontSize = `${s.fontSize}px`;
                btn.style.color = s.color;
                btn.style.backgroundColor = bgColor;
                btn.style.padding = `${s.padding}px`;
                btn.style.borderRadius = `${s.borderRadius}px`;
                btn.style.fontFamily = s.fontFamily;
                
                btn.style.pointerEvents = 'auto'; 

                if (isAlwaysVisible) {
                    btn.classList.add('visible');
                }

                btn.onclick = () => handleOptionClick(opt);

                buttonsContainer.appendChild(btn);
            });

            container.appendChild(buttonsContainer);
        }

        function checkButtonVisibility(currentTime) {
            const buttons = document.querySelectorAll('.interactive-btn');
            buttons.forEach(btn => {
                const start = parseFloat(btn.dataset.startTime);
                const end = parseFloat(btn.dataset.endTime);
                
                if (currentTime >= start && currentTime <= end) {
                    btn.classList.add('visible');
                } else {
                    btn.classList.remove('visible');
                }
            });
        }

        function handleOptionClick(opt) {
            // 1. Aplicar efectes
            if (opt.effects) {
                applyEffects(opt.effects);
            }

            // 2. Marcar com clicat si cal
            if (opt.singleUse) {
                clickedOptions.add(opt.id);
            }

            // 3. Gestionar transició
            const targetNode = projectData.nodes.find(n => n.id === opt.targetNodeId);
            
            if (targetNode && targetNode.transitionType === 'fade') {
                // Fosa a Negre
                fadeOverlay.classList.add('active');
                
                // Esperem 500ms (durada transició CSS) abans de canviar contingut
                setTimeout(() => {
                    loadNode(opt.targetNodeId);
                }, 500);
            } else {
                // Tall sec
                loadNode(opt.targetNodeId);
            }
        }

        // INICIAR APLICACIÓ
        window.onload = init;

    </script>
</body>
</html>
