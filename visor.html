<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualitzador Video Interactiu</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #000;
            color: #fff;
            margin: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
            font-family: sans-serif;
        }

        #player-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #000;
        }

        /* WRAPPER PER MANTENIR ASPECT RATIO I POSICIONS RELATIVES */
        #media-wrapper {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            /* Mida inicial, s'ajustarà per JS */
            width: 100%; 
            height: 100%;
        }

        video, iframe, img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border: none;
            display: block;
        }

        .interactive-btn {
            position: absolute;
            transform: translate(-50%, -50%);
            border: none;
            outline: none;
            transition: opacity 0.5s;
            z-index: 10;
            display: none;
            opacity: 0;
            white-space: nowrap;
            /* Eliminada l'ombra per defecte per evitar requadres en textos transparents */
            /* box-shadow: 0 2px 4px rgba(0,0,0,0.3); */
            align-items: center;
            justify-content: center;
        }

        /* Cursor pointer només si és clicable (té destí o efectes) */
        .interactive-btn.clickable {
            cursor: pointer;
        }
        .interactive-btn.clickable:hover {
            transform: translate(-50%, -50%) scale(1.05);
            z-index: 20;
        }

        .interactive-btn.visible {
            display: flex;
            opacity: 1;
        }

        .interactive-btn.hidden-btn {
             display: none !important;
        }

        /* Loading Spinner */
        .spinner {
            position: absolute;
            z-index: 50;
            border: 4px solid rgba(255, 255, 255, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #3b82f6;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #error-message {
            position: absolute;
            z-index: 200;
            display: none;
            text-align: center;
            color: #f87171;
            background: rgba(20, 20, 20, 0.95);
            padding: 2rem;
            border-radius: 8px;
            border: 1px solid #7f1d1d;
            max-width: 80%;
        }

        /* FADE OVERLAY */
        .fade-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: black;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            z-index: 100;
        }
        
        .fade-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* START BUTTON */
        #start-overlay {
            position: absolute;
            z-index: 150;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            cursor: pointer;
        }
        
        .play-icon-large {
            width: 80px; height: 80px;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            border: 2px solid white;
            transition: transform 0.2s;
        }
        
        #start-overlay:hover .play-icon-large {
            transform: scale(1.1);
            background: rgba(255,255,255,0.4);
        }

        /* MANUAL LOAD OVERLAY */
        #manual-load-overlay {
            position: absolute;
            z-index: 250;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #111827;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            padding: 20px;
        }

        /* TOOLTIP PER HOTSPOTS */
        #custom-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 14px;
            pointer-events: none;
            z-index: 300;
            display: none;
            white-space: nowrap;
            transform: translate(-50%, -100%);
            margin-top: -12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.2);
        }
        #custom-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: rgba(0, 0, 0, 0.85) transparent transparent transparent;
        }
    </style>
</head>
<body>

    <div id="player-container">
        <div id="fade-overlay" class="fade-overlay"></div>
        <div id="loading" class="spinner"></div>
        <div id="custom-tooltip"></div>
        
        <div id="start-overlay" onclick="startPlaybackManual()">
            <div class="play-icon-large">
                <svg width="40" height="40" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polygon points="5 3 19 12 5 21 5 3"></polygon>
                </svg>
            </div>
            <p class="mt-4 text-lg font-semibold">Clica per començar</p>
        </div>

        <div id="manual-load-overlay">
            <div class="text-center max-w-lg">
                <svg class="w-16 h-16 text-gray-500 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                </svg>
                <h2 class="text-2xl font-bold text-white mb-2">Mode Local Detectat</h2>
                <p class="text-gray-400 mb-6">
                    Si us plau, selecciona el fitxer <strong>project.json</strong> manualment per continuar.
                </p>
                <label class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-6 rounded cursor-pointer transition-colors inline-flex items-center gap-2">
                    Seleccionar project.json
                    <input type="file" id="json-input" accept=".json" class="hidden" onchange="loadLocalJSON(this)">
                </label>
            </div>
        </div>

        <div id="error-message">
            <h2 class="text-xl font-bold mb-2">Error</h2>
            <p id="error-text"></p>
        </div>
        
        <!-- WRAPPER RESPONSIVE -->
        <div id="media-wrapper">
             <!-- El contingut (video/iframe i botons) s'injectarà aquí -->
        </div>

    </div>

    <script>
        // CONFIGURACIÓ
        const JSON_FILE = 'project.json'; 
        
        // ESTAT
        let projectData = null;
        let currentNode = null;
        let clickedOptions = new Set(); 
        let runtimeVariables = {};     
        let videoElement = null;
        let imageTimer = null; 
        let currentImageTime = 0; 
        let animationFrameId = null; 
        let currentAspectRatio = 16/9; // Default ratio

        // ELEMENTS DOM
        const container = document.getElementById('player-container');
        const mediaWrapper = document.getElementById('media-wrapper');
        const loading = document.getElementById('loading');
        const errorDiv = document.getElementById('error-message');
        const errorText = document.getElementById('error-text');
        const fadeOverlay = document.getElementById('fade-overlay');
        const startOverlay = document.getElementById('start-overlay');
        const manualLoadOverlay = document.getElementById('manual-load-overlay');
        const tooltip = document.getElementById('custom-tooltip');

        // --- UTILITATS ---

        function hexToRgba(hex, alpha = 1) {
            let r = 0, g = 0, b = 0;
            if (!hex) return `rgba(0,0,0,${alpha})`;
            if (hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            } else if (hex.length === 7) {
                r = parseInt(hex[1] + hex[2], 16);
                g = parseInt(hex[3] + hex[4], 16);
                b = parseInt(hex[5] + hex[6], 16);
            }
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function getYoutubeId(url) {
            if (!url) return null;
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        function isImageFile(url) {
            if (!url) return false;
            return /\.(jpg|jpeg|png|gif|webp)$/i.test(url) || url.startsWith('data:image');
        }

        function showError(msg) {
            loading.style.display = 'none';
            startOverlay.style.display = 'none';
            manualLoadOverlay.style.display = 'none';
            errorDiv.style.display = 'block';
            errorText.innerHTML = msg; 
        }

        // --- RESPONSIVITAT I ESCALAT ---

        function resizeWrapper() {
            if (!mediaWrapper) return;
            const containerW = container.clientWidth;
            const containerH = container.clientHeight;
            const containerRatio = containerW / containerH;

            let finalW, finalH;

            if (containerRatio > currentAspectRatio) {
                // Pantalla més ampla que el vídeo -> Limita l'alçada
                finalH = containerH;
                finalW = finalH * currentAspectRatio;
            } else {
                // Pantalla més alta que el vídeo -> Limita l'amplada
                finalW = containerW;
                finalH = finalW / currentAspectRatio;
            }

            mediaWrapper.style.width = `${finalW}px`;
            mediaWrapper.style.height = `${finalH}px`;
            
            // Actualitzar mida lletra botons
            updateButtonsFontSize(finalH);
        }

        // Escalar la font proporcionalment a l'alçada del vídeo (referència 900px)
        function updateButtonsFontSize(currentHeight) {
            const buttons = document.querySelectorAll('.interactive-btn');
            buttons.forEach(btn => {
                const baseSize = parseFloat(btn.dataset.baseFontSize || 16);
                const scaledSize = (baseSize / 900) * currentHeight;
                btn.style.fontSize = `${scaledSize}px`;
            });
        }

        window.addEventListener('resize', resizeWrapper);

        // --- VARIABLES & LÒGICA ---

        function initVariables() {
            if (projectData.variables) {
                projectData.variables.forEach(v => {
                    runtimeVariables[v.name] = v.value;
                });
            }
        }

        function checkCondition(condition) {
            if (!condition || !condition.variable) return true;
            const currentVal = runtimeVariables[condition.variable];
            const safeCurrentVal = currentVal !== undefined ? currentVal : 0;
            const targetVal = parseFloat(condition.value);
            switch (condition.operator) {
                case 'eq': return safeCurrentVal == targetVal;
                case 'neq': return safeCurrentVal != targetVal;
                case 'gt': return safeCurrentVal > targetVal;
                case 'lt': return safeCurrentVal < targetVal;
                default: return true;
            }
        }

        function applyEffects(effects) {
            if (!effects) return;
            effects.forEach(eff => {
                if (!eff.variable) return;
                const currentVal = runtimeVariables[eff.variable] || 0;
                const effectVal = parseFloat(eff.value);
                if (eff.operator === 'set') runtimeVariables[eff.variable] = effectVal;
                if (eff.operator === 'add') runtimeVariables[eff.variable] = currentVal + effectVal;
                if (eff.operator === 'sub') runtimeVariables[eff.variable] = currentVal - effectVal;
            });
        }

        // --- TOOLTIP ---

        function showTooltip(text, targetBtn) {
            tooltip.textContent = text;
            tooltip.style.display = 'block';
            const top = parseFloat(targetBtn.style.top);
            const left = parseFloat(targetBtn.style.left);
            
            // Tooltip relatiu al wrapper (com que està dins del wrapper per posicionament absolut)
            // No, el tooltip està fora (body > player-container > custom-tooltip).
            // Hem de calcular la posició absoluta en pantalla o posar-lo dins del wrapper.
            // Solució: Posar-lo dins de media-wrapper per fer servir % igual.
            mediaWrapper.appendChild(tooltip);
            tooltip.style.top = `${top}%`;
            tooltip.style.left = `${left}%`;
        }

        function hideTooltip() {
            tooltip.style.display = 'none';
        }


        // --- CARREGA MANUAL ---
        window.loadLocalJSON = function(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    projectData = JSON.parse(e.target.result);
                    manualLoadOverlay.style.display = 'none';
                    startProject();
                } catch (err) {
                    alert("Error en llegir el JSON: " + err.message);
                }
            };
            reader.readAsText(file);
        };

        // --- INICI ---

        async function init() {
            try {
                if (window.location.protocol === 'file:') {
                    loading.style.display = 'none';
                    manualLoadOverlay.style.display = 'flex';
                    return;
                }
                const response = await fetch(JSON_FILE);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                projectData = await response.json();
                startProject();
            } catch (err) {
                console.warn("Càrrega automàtica fallida:", err);
                loading.style.display = 'none';
                manualLoadOverlay.style.display = 'flex';
            }
        }

        function startProject() {
            if (!projectData || !projectData.nodes || projectData.nodes.length === 0) {
                showError("El fitxer JSON no conté escenes vàlides.");
                return;
            }
            initVariables();
            const startId = projectData.startNodeId || projectData.nodes[0].id;
            const startNode = projectData.nodes.find(n => n.id === startId);
            if (startNode && startNode.transitionType === 'fade') {
                fadeOverlay.classList.add('active');
            }
            loadNode(startId);
            loop();
        }

        function loadNode(nodeId) {
            const node = projectData.nodes.find(n => n.id === nodeId);
            if (!node) {
                showError("Node no trobat: " + nodeId);
                return;
            }
            currentNode = node;
            renderScene(node);
        }

        function renderScene(node) {
            // Netejar wrapper
            mediaWrapper.innerHTML = '';
            
            // Netejar estat
            loading.style.display = 'block';
            videoElement = null;
            if (imageTimer) clearInterval(imageTimer);
            currentImageTime = 0;
            hideTooltip();

            const youtubeId = getYoutubeId(node.videoUrl);
            let src = node.videoUrl;
            if (!src.match(/^(http|https|blob):/) && !src.startsWith('videos/')) {
                 src = `videos/${src}`;
            }

            const onContentReady = () => {
                loading.style.display = 'none';
                startOverlay.style.display = 'none'; 
                // Calcular Aspect Ratio un cop carregat
                resizeWrapper(); 
                
                if (node.transitionType === 'fade') {
                    setTimeout(() => { fadeOverlay.classList.remove('active'); }, 100);
                } else {
                    fadeOverlay.classList.remove('active');
                }
            };

            if (youtubeId) {
                currentAspectRatio = 16/9; // Assumeix 16:9 per YT
                const iframe = document.createElement('iframe');
                iframe.src = `https://www.youtube.com/embed/${youtubeId}?rel=0&controls=0&autoplay=1&modestbranding=1`;
                iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
                iframe.allowFullscreen = true;
                iframe.onload = onContentReady;
                mediaWrapper.appendChild(iframe);
                renderButtons(node, true);
                resizeWrapper(); // Forçar resize immediat amb ratio 16:9

            } else if (isImageFile(src)) {
                const img = document.createElement('img');
                img.src = src;
                img.onload = () => {
                    // Calcular ratio imatge
                    if (img.naturalWidth && img.naturalHeight) {
                        currentAspectRatio = img.naturalWidth / img.naturalHeight;
                    }
                    onContentReady();
                    imageTimer = setInterval(() => {
                        currentImageTime += 0.05; 
                    }, 50);
                };
                img.onerror = () => {
                    loading.style.display = 'none';
                    showError(`Imatge no trobada: <strong>${src}</strong>`);
                };
                mediaWrapper.appendChild(img);
                renderButtons(node, false);
            } else {
                const video = document.createElement('video');
                video.src = src;
                video.playsInline = true;
                video.muted = false; // Intentar amb so
                video.autoplay = true;
                video.controls = false; 
                
                video.onloadedmetadata = () => {
                     if (video.videoWidth && video.videoHeight) {
                         currentAspectRatio = video.videoWidth / video.videoHeight;
                         resizeWrapper();
                     }
                };

                video.oncanplay = onContentReady;
                
                video.onerror = (e) => {
                    loading.style.display = 'none';
                    if (video.error && video.error.code === 4) {
                        showError(`Vídeo no trobat: <strong>${src}</strong>.`);
                    } else {
                        showError("Error carregant el vídeo.");
                    }
                };
                
                mediaWrapper.appendChild(video);
                videoElement = video;
                
                renderButtons(node, false);
                
                video.play().catch(e => {
                    console.log("Autoplay bloquejat");
                    loading.style.display = 'none';
                    startOverlay.style.display = 'flex';
                });
            }
        }

        window.startPlaybackManual = function() {
            if (videoElement) {
                videoElement.muted = false; 
                videoElement.play()
                    .then(() => {
                        startOverlay.style.display = 'none';
                    })
                    .catch(e => showError(e.message));
            }
        };

        function renderButtons(node, isAlwaysVisible) {
            const buttonsContainer = document.createElement('div');
            buttonsContainer.id = 'buttons-layer';
            // Aquest layer ara està DINS del wrapper, així que 100% és 100% del vídeo
            buttonsContainer.style.position = 'absolute';
            buttonsContainer.style.top = '0';
            buttonsContainer.style.left = '0';
            buttonsContainer.style.width = '100%';
            buttonsContainer.style.height = '100%';
            buttonsContainer.style.pointerEvents = 'none'; 

            node.options.forEach(opt => {
                if (opt.singleUse && clickedOptions.has(opt.id)) return;

                if (opt.condition && opt.condition.variable) {
                    if (!checkCondition(opt.condition)) return;
                }

                const btn = document.createElement('button');
                btn.className = 'interactive-btn';
                btn.textContent = opt.label;
                btn.dataset.id = opt.id;
                btn.dataset.startTime = opt.startTime;
                btn.dataset.endTime = opt.endTime || 99999;
                
                // Estils Base (Des del JSON)
                const s = opt.style || {};
                const bgColor = hexToRgba(s.backgroundColor, s.bgOpacity !== undefined ? s.bgOpacity : 1);
                
                // Guardem la mida base per poder escalar-la al resize
                btn.dataset.baseFontSize = s.fontSize || 16; 
                
                btn.style.color = s.color;
                btn.style.backgroundColor = bgColor;
                btn.style.padding = `${s.padding}px`;
                btn.style.borderRadius = `${s.borderRadius}px`;
                btn.style.fontFamily = s.fontFamily;
                
                // Nous estils de text (Bold, Italic)
                if (s.fontWeight) btn.style.fontWeight = s.fontWeight;
                if (s.fontStyle) btn.style.fontStyle = s.fontStyle;
                
                // Hotspot Mode
                if (opt.isHotspot) {
                    btn.style.opacity = '0'; 
                    btn.style.backgroundColor = 'transparent'; 
                    btn.style.color = 'transparent';
                    if (opt.hoverText) {
                        btn.onmouseenter = () => showTooltip(opt.hoverText, btn);
                        btn.onmouseleave = hideTooltip;
                    }
                }

                // Definir si és clickable (Té acció o és text pla?)
                // Si targetNodeId és buit o null, és text estàtic (no pointer)
                // Excepte si té efectes (canvi variable), llavors sí que és clickable
                const isClickable = !!(opt.targetNodeId || (opt.effects && opt.effects.length > 0));
                
                if (isClickable) {
                    btn.classList.add('clickable');
                    btn.style.pointerEvents = 'auto'; 
                    btn.onclick = () => handleOptionClick(opt);
                } else {
                    // Botó tipus Text (no fa res)
                    btn.style.pointerEvents = 'auto'; // Per permetre hover si calgués, o selection
                    btn.style.cursor = 'default';
                }

                // Posició inicial (percentatges relatius al wrapper)
                const formatPos = (val) => typeof val === 'string' && val.endsWith('%') ? val : `${val}%`;
                btn.style.top = formatPos(s.top);
                btn.style.left = formatPos(s.left);
                btn.style.width = typeof s.width === 'number' ? `${s.width}px` : s.width; // A l'editor ara són % normalment, però mantenim compatibilitat
                if(String(s.width).indexOf('%') === -1 && String(s.width) !== 'auto') btn.style.width = s.width + '%'; // Forçar % si ve de l'editor nou
                btn.style.height = typeof s.height === 'number' ? `${s.height}px` : s.height;
                 if(String(s.height).indexOf('%') === -1 && String(s.height) !== 'auto') btn.style.height = s.height + '%';

                if (isAlwaysVisible) {
                    btn.classList.add('visible');
                    if (opt.isHotspot) btn.style.opacity = '0'; 
                }

                buttonsContainer.appendChild(btn);
            });

            mediaWrapper.appendChild(buttonsContainer);
            // Trigger inicial de font size
            updateButtonsFontSize(mediaWrapper.clientHeight);
        }

        // Interpolació
        function updateKeyframes(currentTime) {
            if (!currentNode) return;
            const buttons = document.querySelectorAll('.interactive-btn');
            
            buttons.forEach(btn => {
                const optId = btn.dataset.id;
                const opt = currentNode.options.find(o => o.id === optId);
                
                if (opt && opt.useKeyframes && opt.keyframes && opt.keyframes.length > 0) {
                    const sortedKeys = [...opt.keyframes].sort((a, b) => a.time - b.time);
                    let newStyle = {};
                    const getVal = (k, p) => k[p] !== undefined ? k[p] : opt.style[p];

                    if (currentTime <= sortedKeys[0].time) {
                        const k = sortedKeys[0];
                        newStyle = { left: k.left, top: k.top, width: getVal(k, 'width'), height: getVal(k, 'height') };
                    } else if (currentTime >= sortedKeys[sortedKeys.length - 1].time) {
                        const last = sortedKeys[sortedKeys.length - 1];
                        newStyle = { left: last.left, top: last.top, width: getVal(last, 'width'), height: getVal(last, 'height') };
                    } else {
                        for (let i = 0; i < sortedKeys.length - 1; i++) {
                            const k1 = sortedKeys[i];
                            const k2 = sortedKeys[i + 1];
                            if (currentTime >= k1.time && currentTime < k2.time) {
                                const range = k2.time - k1.time;
                                const progress = (currentTime - k1.time) / range;
                                
                                const w1 = getVal(k1, 'width'), w2 = getVal(k2, 'width');
                                const h1 = getVal(k1, 'height'), h2 = getVal(k2, 'height');

                                const w = w1 + (w2 - w1) * progress;
                                const h = h1 + (h2 - h1) * progress;
                                
                                const l = k1.left + (k2.left - k1.left) * progress;
                                const t = k1.top + (k2.top - k1.top) * progress;
                                
                                newStyle = { left: l, top: t, width: w, height: h };
                                break;
                            }
                        }
                    }

                    if (newStyle.left !== undefined) {
                        btn.style.left = `${newStyle.left}%`;
                        btn.style.top = `${newStyle.top}%`;
                        if (newStyle.width) btn.style.width = `${newStyle.width}%`;
                        if (newStyle.height) btn.style.height = `${newStyle.height}%`;
                    }
                }
            });
        }

        function checkButtonVisibility(currentTime) {
            updateKeyframes(currentTime);

            const buttons = document.querySelectorAll('.interactive-btn');
            buttons.forEach(btn => {
                const start = parseFloat(btn.dataset.startTime);
                const end = parseFloat(btn.dataset.endTime);
                
                if (currentTime >= start && currentTime <= end) {
                    btn.classList.add('visible');
                    btn.classList.remove('hidden-btn');
                     const opt = currentNode.options.find(o => o.id === btn.dataset.id);
                     if (opt && opt.isHotspot) btn.style.opacity = '0';
                } else {
                    btn.classList.remove('visible');
                    btn.classList.add('hidden-btn');
                }
            });
        }

        function handleOptionClick(opt) {
            if (opt.effects) applyEffects(opt.effects);
            if (opt.singleUse) clickedOptions.add(opt.id);

            // Si no hi ha target (Botó de text), no fem res més
            if (!opt.targetNodeId) return;

            const targetNode = projectData.nodes.find(n => n.id === opt.targetNodeId);
            
            if (targetNode && targetNode.transitionType === 'fade') {
                fadeOverlay.classList.add('active');
                setTimeout(() => {
                    loadNode(opt.targetNodeId);
                }, 500);
            } else {
                loadNode(opt.targetNodeId);
            }
        }

        function loop() {
            if (currentNode && !document.hidden) {
                let time = 0;
                if (videoElement && !videoElement.paused) {
                    time = videoElement.currentTime;
                } else if (imageTimer) {
                    time = currentImageTime;
                }
                
                if (videoElement || imageTimer) {
                    checkButtonVisibility(time);
                }
            }
            animationFrameId = requestAnimationFrame(loop);
        }

        window.onload = init;

    </script>
</body>
</html>
