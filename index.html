<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Vídeo Interactiu - Gamelab UAB</title>
    
    <!-- Estils Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Babel per processar JSX al navegador -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { background-color: #111827; color: white; overflow: hidden; margin: 0; }
        /* Scrollbars personalitzades */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        
        #root:empty::before {
            content: 'Carregant editor...';
            display: flex;
            height: 100vh;
            width: 100vw;
            align-items: center;
            justify-content: center;
            color: #6b7280;
        }

        /* Tooltip style */
        .hotspot-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            white-space: nowrap;
            z-index: 100;
            transform: translate(-50%, -100%);
            margin-top: -8px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useRef, useEffect, useCallback } from 'https://esm.sh/react@18.2.0';
        import { createRoot } from 'https://esm.sh/react-dom@18.2.0/client';
        import { 
          Play, Pause, Plus, Trash2, Save, Layout, 
          Type, Clock, Palette, MonitorPlay, Settings,
          ChevronRight, ArrowRightCircle, Image as ImageIcon,
          Network, Upload, FileVideo, Move, X, Maximize,
          GripHorizontal, Scaling, MousePointer2,
          Download, FolderOpen, Flag, PlayCircle,
          Copy, Clipboard, AlertCircle, Ghost, Film, FileUp, AlertTriangle, CheckCircle, Youtube,
          Database, Zap, Eye, EyeOff, Layers, Package, Lock,
          Undo, Redo, MapPin, Target, Image
        } from 'https://esm.sh/lucide-react@0.263.1';

        // --- Utilitats ---
        const hexToRgba = (hex, alpha = 1) => {
          let r = 0, g = 0, b = 0;
          if (!hex) return `rgba(0,0,0,${alpha})`;
          if (hex.length === 4) {
            r = parseInt(hex[1] + hex[1], 16);
            g = parseInt(hex[2] + hex[2], 16);
            b = parseInt(hex[3] + hex[3], 16);
          } else if (hex.length === 7) {
            r = parseInt(hex[1] + hex[2], 16);
            g = parseInt(hex[3] + hex[4], 16);
            b = parseInt(hex[5] + hex[6], 16);
          }
          return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        };

        const getVideoSrc = (url) => {
            if (!url) return '';
            if (url.match(/^(http|https|blob):/) || url.startsWith('www.')) return url;
            if (url.startsWith('videos/')) return url;
            return `videos/${url}`;
        };

        const getYoutubeId = (url) => {
            if (!url) return null;
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        };

        const isImageFile = (url) => {
            if (!url) return false;
            return /\.(jpg|jpeg|png|gif|webp)$/i.test(url) || url.startsWith('data:image');
        };

        // --- LÒGICA D'INTERPOLACIÓ DE KEYFRAMES (POSICIÓ + MIDA) ---
        const getInterpolatedStyle = (opt, currentTime) => {
            if (!opt.useKeyframes || !opt.keyframes || opt.keyframes.length === 0) {
                return opt.style;
            }
            const sortedKeys = [...opt.keyframes].sort((a, b) => a.time - b.time);
            const getVal = (k, prop) => k[prop] !== undefined ? k[prop] : opt.style[prop];

            if (currentTime <= sortedKeys[0].time) {
                const k = sortedKeys[0];
                return { ...opt.style, left: k.left, top: k.top, width: getVal(k, 'width'), height: getVal(k, 'height') };
            }
            if (currentTime >= sortedKeys[sortedKeys.length - 1].time) {
                const last = sortedKeys[sortedKeys.length - 1];
                return { ...opt.style, left: last.left, top: last.top, width: getVal(last, 'width'), height: getVal(last, 'height') };
            }
            for (let i = 0; i < sortedKeys.length - 1; i++) {
                const k1 = sortedKeys[i];
                const k2 = sortedKeys[i + 1];
                if (currentTime >= k1.time && currentTime < k2.time) {
                    const range = k2.time - k1.time;
                    const progress = (currentTime - k1.time) / range;
                    const l1 = k1.left, l2 = k2.left;
                    const t1 = k1.top, t2 = k2.top;
                    const w1 = getVal(k1, 'width'), w2 = getVal(k2, 'width');
                    const h1 = getVal(k1, 'height'), h2 = getVal(k2, 'height');

                    const currentLeft = l1 + (l2 - l1) * progress;
                    const currentTop = t1 + (t2 - t1) * progress;
                    const currentWidth = w1 + (w2 - w1) * progress;
                    const currentHeight = h1 + (h2 - h1) * progress;

                    return { ...opt.style, left: currentLeft, top: currentTop, width: currentWidth, height: currentHeight };
                }
            }
            return opt.style;
        };

        const loadJSZip = () => {
          return new Promise((resolve, reject) => {
            if (window.JSZip) return resolve(window.JSZip);
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
            script.onload = () => resolve(window.JSZip);
            script.onerror = reject;
            document.head.appendChild(script);
          });
        };

        // --- Dades Inicials ---
        const INITIAL_NODES = [];

        // --- Component de Gràfic ---
        const NodeGraph = ({ 
          nodes, onUpdateNode, onSelectNode, onDeleteNode, startNodeId, onSetStartNode, onPreviewNode 
        }) => {
          const [draggingNodeId, setDraggingNodeId] = useState(null);
          const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
          const containerRef = useRef(null);

          const handleMouseDown = (e, nodeId) => {
            e.stopPropagation(); 
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;
            const containerRect = containerRef.current.getBoundingClientRect();
            const scrollLeft = containerRef.current.scrollLeft;
            const scrollTop = containerRef.current.scrollTop;
            const mouseX = e.clientX - containerRect.left + scrollLeft;
            const mouseY = e.clientY - containerRect.top + scrollTop;
            setDragOffset({ x: mouseX - (node.position?.x || 0), y: mouseY - (node.position?.y || 0) });
            setDraggingNodeId(nodeId);
          };

          const handleMouseMove = useCallback((e) => {
            if (!draggingNodeId) return;
            const containerRect = containerRef.current.getBoundingClientRect();
            const scrollLeft = containerRef.current.scrollLeft;
            const scrollTop = containerRef.current.scrollTop;
            const mouseX = e.clientX - containerRect.left + scrollLeft;
            const mouseY = e.clientY - containerRect.top + scrollTop;
            const newX = mouseX - dragOffset.x;
            const newY = mouseY - dragOffset.y;
            const updatedNode = nodes.find(n => n.id === draggingNodeId);
            if (updatedNode) {
              onUpdateNode(draggingNodeId, 'position', { x: newX, y: newY });
            }
          }, [draggingNodeId, dragOffset, nodes, onUpdateNode]);

          const handleMouseUp = () => setDraggingNodeId(null);

          useEffect(() => {
            if (draggingNodeId) {
              window.addEventListener('mousemove', handleMouseMove);
              window.addEventListener('mouseup', handleMouseUp);
            } else {
              window.removeEventListener('mousemove', handleMouseMove);
              window.removeEventListener('mouseup', handleMouseUp);
            }
            return () => {
              window.removeEventListener('mousemove', handleMouseMove);
              window.removeEventListener('mouseup', handleMouseUp);
            };
          }, [draggingNodeId, handleMouseMove]);

          const addOptionToNode = (nodeId) => {
            const node = nodes.find(n => n.id === nodeId);
            const targetId = nodes.length > 0 ? nodes[0].id : nodeId; 
            const newOption = {
              id: `opt-${Date.now()}`,
              label: 'Nova Opció',
              targetNodeId: targetId, 
              startTime: 0,
              endTime: 10,
              singleUse: false,
              style: { top: 50, left: 50, width: 120, height: 40, fontSize: 14, color: '#fff', backgroundColor: '#333', bgOpacity: 1, padding: 8, borderRadius: 4, fontFamily: 'sans-serif' }
            };
            onUpdateNode(nodeId, 'options', [...node.options, newOption]);
          };

          const updateNodeOption = (nodeId, optionId, field, value) => {
            const node = nodes.find(n => n.id === nodeId);
            const updatedOptions = node.options.map(opt => opt.id === optionId ? { ...opt, [field]: value } : opt);
            onUpdateNode(nodeId, 'options', updatedOptions);
          };
          
          const deleteNodeOption = (nodeId, optionId) => {
            const node = nodes.find(n => n.id === nodeId);
            const updatedOptions = node.options.filter(opt => opt.id !== optionId);
            onUpdateNode(nodeId, 'options', updatedOptions);
          };

          return (
            <div ref={containerRef} className="flex-1 bg-gray-950 overflow-auto relative min-h-full cursor-crosshair" style={{ backgroundImage: 'radial-gradient(#374151 1px, transparent 1px)', backgroundSize: '20px 20px' }}>
              <div className="relative" style={{ minWidth: '3000px', minHeight: '3000px' }}>
                {nodes.length === 0 && (
                    <div className="absolute top-20 left-20 text-gray-500 flex flex-col items-center pointer-events-none">
                        <Network size={64} className="mb-4 opacity-20"/>
                        <p className="text-xl font-semibold opacity-40">Llenç buit</p>
                        <p className="text-sm opacity-30">Afegeix una nova escena per començar</p>
                    </div>
                )}
                <svg className="absolute inset-0 w-full h-full pointer-events-none z-0">
                  <defs><marker id="arrowhead" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto"><path d="M2,2 L10,6 L2,10 L2,2" fill="#6b7280" /></marker></defs>
                  {nodes.map(node => node.options.map((opt, idx) => {
                      const targetNode = nodes.find(n => n.id === opt.targetNodeId);
                      if (!targetNode) return null;
                      
                      const isConditional = (opt.condition && opt.condition.variable) || opt.singleUse;
                      const dashArray = isConditional ? "5,5" : "0";

                      const startX = (node.position?.x || 0) + 280;
                      const startY = (node.position?.y || 0) + 110 + (idx * 36);
                      const endX = targetNode.position?.x || 0;
                      const endY = (targetNode.position?.y || 0) + 30;
                      const cp1X = startX + (endX - startX) / 2;
                      
                      return (
                        <path 
                            key={opt.id} 
                            d={`M ${startX} ${startY} C ${cp1X} ${startY}, ${cp1X} ${endY}, ${endX} ${endY}`} 
                            stroke={node.color || '#4b5563'} 
                            strokeWidth="3" 
                            fill="none" 
                            markerEnd="url(#arrowhead)" 
                            className="opacity-60" 
                            strokeDasharray={dashArray}
                        />
                      );
                  }))}
                </svg>
                {nodes.map(node => (
                  <div key={node.id} className="absolute w-[280px] bg-gray-800 rounded-lg shadow-2xl border border-gray-700 flex flex-col z-10 group" style={{ left: node.position?.x || 0, top: node.position?.y || 0 }}>
                    <div className="h-10 rounded-t-lg flex items-center justify-between px-3 cursor-move select-none" style={{ backgroundColor: node.color || '#374151' }} onMouseDown={(e) => handleMouseDown(e, node.id)}>
                      <div className="flex items-center gap-2 text-white font-bold text-sm truncate max-w-[140px]"><Move size={14} className="opacity-50" /><span className="truncate">{node.title}</span></div>
                      <div className="flex items-center gap-1">
                        <button onClick={(e) => { e.stopPropagation(); onPreviewNode(node.id); }} className="text-white/80 hover:text-green-300 p-1 hover:bg-black/20 rounded" title="Previsualitzar"><PlayCircle size={14} /></button>
                        <button onClick={(e) => { e.stopPropagation(); onSetStartNode(node.id); }} className={`p-1 rounded hover:bg-black/20 ${startNodeId === node.id ? 'text-green-400' : 'text-white/40 hover:text-white'}`} title="Marcar inici"><Flag size={14} fill={startNodeId === node.id ? "currentColor" : "none"}/></button>
                        <div className="w-px h-4 bg-white/20 mx-1"></div>
                        <input type="color" value={node.color || '#374151'} onChange={(e) => onUpdateNode(node.id, 'color', e.target.value)} className="w-5 h-5 rounded cursor-pointer border-none bg-transparent" />
                        <button onClick={(e) => { e.stopPropagation(); onDeleteNode(node.id); }} className="text-white/60 hover:text-red-400 hover:bg-black/20 rounded p-1 transition-colors"><X size={14} /></button>
                      </div>
                    </div>
                    <div className="p-3 space-y-3 bg-gray-800 rounded-b-lg">
                      <input type="text" value={node.title} onChange={(e) => onUpdateNode(node.id, 'title', e.target.value)} className="w-full bg-gray-900 border border-gray-700 rounded px-2 py-1 text-xs text-gray-200 outline-none" placeholder="Títol..." />
                      <div className="space-y-1">
                        <div className="flex justify-between items-center text-[10px] text-gray-500 uppercase tracking-wider font-semibold"><span>Opcions ({node.options.length})</span><button onClick={() => addOptionToNode(node.id)} className="hover:text-blue-400"><Plus size={12} /></button></div>
                        {node.options.map((opt) => (
                          <div key={opt.id} className="flex items-center gap-1 bg-gray-900 p-1.5 rounded border border-gray-700 relative">
                            <input type="text" value={opt.label} onChange={(e) => updateNodeOption(node.id, opt.id, 'label', e.target.value)} className="w-24 bg-transparent border-none text-xs text-white p-0 truncate font-medium" />
                            
                            <div className="flex gap-0.5">
                                {opt.singleUse && <Ghost size={10} className="text-purple-400" title="Un sol ús"/>}
                                {opt.condition && opt.condition.variable && <Lock size={10} className="text-yellow-400" title={`Condició: ${opt.condition.variable}`}/>}
                                {opt.effects && opt.effects.length > 0 && <Zap size={10} className="text-blue-400" title="Canvi variable"/>}
                                {opt.useKeyframes && <MapPin size={10} className="text-orange-400" title="Animació"/>}
                            </div>

                            <ArrowRightCircle size={12} className="text-gray-500 shrink-0" />
                            {/* FILTER: Exclude current node from options */}
                            <select value={opt.targetNodeId} onChange={(e) => updateNodeOption(node.id, opt.id, 'targetNodeId', e.target.value)} className="flex-1 bg-gray-800 text-[10px] text-gray-300 border-none rounded py-0.5 px-1 h-5 cursor-pointer">
                                {nodes.filter(n => n.id !== node.id).map(n => <option key={n.id} value={n.id}>{n.title}</option>)}
                                {!nodes.find(n => n.id === opt.targetNodeId) && <option value="" disabled>Destí esborrat</option>}
                            </select>
                            <button onClick={() => deleteNodeOption(node.id, opt.id)} className="text-gray-600 hover:text-red-400"><Trash2 size={12} /></button>
                          </div>
                        ))}
                      </div>
                      <button onClick={() => { onSelectNode(node.id); }} className="w-full mt-2 py-1 bg-gray-700 hover:bg-gray-600 text-xs text-gray-300 rounded flex items-center justify-center gap-2"><Settings size={12} /> Editar</button>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          );
        };

        function App() {
          const [nodes, setNodes] = useState(() => {
            const saved = localStorage.getItem('intervideo_project');
            return saved ? JSON.parse(saved).nodes : INITIAL_NODES;
          });
          const [variables, setVariables] = useState(() => {
            const saved = localStorage.getItem('intervideo_project');
            return saved ? JSON.parse(saved).variables || [] : [];
          });
          const [selectedNodeId, setSelectedNodeId] = useState(null);
          const [startNodeId, setStartNodeId] = useState(() => {
            const saved = localStorage.getItem('intervideo_project');
            return saved ? JSON.parse(saved).startNodeId : null;
          });
          const [mode, setMode] = useState('edit'); 
          const [currentNodeId, setCurrentNodeId] = useState(null); 
          const [selectedOptionId, setSelectedOptionId] = useState(null);
          const [hoveredOptionId, setHoveredOptionId] = useState(null); 
          
          // Video State
          const [isPlaying, setIsPlaying] = useState(false);
          const [currentTime, setCurrentTime] = useState(0);
          const [duration, setDuration] = useState(0);
          const [videoError, setVideoError] = useState(null);
          const [fileBlobs, setFileBlobs] = useState({}); 
          const [videosLoadedCount, setVideosLoadedCount] = useState(0); 
          
          // Logic State
          const [clickedOptions, setClickedOptions] = useState(new Set()); 
          const [runtimeVariables, setRuntimeVariables] = useState({}); 
          const [showMissingFilesModal, setShowMissingFilesModal] = useState(false); 
          const [showLoadModal, setShowLoadModal] = useState(false); 
          const [showVariablesModal, setShowVariablesModal] = useState(false);
          const [showDeleteModal, setShowDeleteModal] = useState(false);
          const [nodeToDelete, setNodeToDelete] = useState(null);
          
          // Transition State
          const [isTransitioning, setIsTransitioning] = useState(false);

          // Inspector State
          const [activeTab, setActiveTab] = useState('properties'); 

          // Dragging & Clipboard
          const [dragState, setDragState] = useState({ isDragging: false, type: null, targetId: null, startX: 0, startY: 0, initialVal: {} });
          const [clipboardStyle, setClipboardStyle] = useState(null);

          // Undo/Redo History
          const historyRef = useRef({ past: [], future: [] });

          const videoRef = useRef(null);
          const videoContainerRef = useRef(null);
          const timelineTrackRef = useRef(null); 
          const fileInputRef = useRef(null);
          const projectInputRef = useRef(null); 
          const bulkVideoInputRef = useRef(null); 
          const requestRef = useRef();
          const lastTimeRef = useRef(Date.now()); // For manual timing

          const activeNodeId = mode === 'preview' ? currentNodeId : selectedNodeId;
          const activeNode = nodes.find(n => n.id === activeNodeId); 
          const youtubeId = activeNode ? getYoutubeId(activeNode.videoUrl) : null;
          const isImage = activeNode ? isImageFile(activeNode.videoUrl) : false;

          // --- AUTO-SAVE ---
          useEffect(() => {
            const projectData = { nodes, variables, startNodeId };
            localStorage.setItem('intervideo_project', JSON.stringify(projectData));
          }, [nodes, variables, startNodeId]);

          // --- UNDO / REDO LOGIC ---
          const saveHistory = () => {
            historyRef.current.past.push({ 
                nodes: JSON.parse(JSON.stringify(nodes)), 
                variables: JSON.parse(JSON.stringify(variables)), 
                startNodeId 
            });
            if (historyRef.current.past.length > 50) historyRef.current.past.shift();
            historyRef.current.future = [];
          };

          const undo = useCallback(() => {
            if (historyRef.current.past.length === 0) return;
            const previous = historyRef.current.past.pop();
            historyRef.current.future.push({ 
                nodes: JSON.parse(JSON.stringify(nodes)), 
                variables: JSON.parse(JSON.stringify(variables)), 
                startNodeId 
            });
            setNodes(previous.nodes);
            setVariables(previous.variables);
            setStartNodeId(previous.startNodeId);
          }, [nodes, variables, startNodeId]);

          const redo = useCallback(() => {
            if (historyRef.current.future.length === 0) return;
            const next = historyRef.current.future.pop();
            historyRef.current.past.push({ 
                nodes: JSON.parse(JSON.stringify(nodes)), 
                variables: JSON.parse(JSON.stringify(variables)), 
                startNodeId 
            });
            setNodes(next.nodes);
            setVariables(next.variables);
            setStartNodeId(next.startNodeId);
          }, [nodes, variables, startNodeId]);

          // --- ANIMATION LOOP (Updated for Images) ---
          const animate = () => {
             const now = Date.now();
             const dt = (now - lastTimeRef.current) / 1000;
             lastTimeRef.current = now;

             if (videoRef.current && !videoRef.current.paused && !videoRef.current.ended) {
                 setCurrentTime(videoRef.current.currentTime);
             } else if (isPlaying && isImage) {
                 // Manual increment for images in preview/play mode
                 setCurrentTime(prev => {
                     const next = prev + dt;
                     return next >= 10 ? 10 : next; // Default image duration 10s
                 });
             }
             requestRef.current = requestAnimationFrame(animate);
          };

          useEffect(() => {
              requestRef.current = requestAnimationFrame(animate);
              return () => cancelAnimationFrame(requestRef.current);
          }, [isPlaying, isImage]); // Dependencies help but ref usage is key

          // --- TOGGLE PLAY ---
          const togglePlay = useCallback(() => {
              if (youtubeId) return;
              
              if (isImage) {
                  setIsPlaying(p => !p);
                  return;
              }

              if (videoRef.current) {
                  if (videoRef.current.paused) {
                      const playPromise = videoRef.current.play();
                      if (playPromise !== undefined) {
                          playPromise.then(() => setIsPlaying(true)).catch(() => setIsPlaying(false));
                      }
                  } else {
                      videoRef.current.pause();
                      setIsPlaying(false);
                  }
              }
          }, [youtubeId, isImage]);

          // --- KEYBOARD SHORTCUTS ---
          useEffect(() => {
            const handleKeyDown = (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                    e.preventDefault();
                    if (e.shiftKey) redo();
                    else undo();
                    return;
                }
                if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
                    e.preventDefault();
                    redo();
                    return;
                }
                // SPACE: Play/Pause
                if (e.code === 'Space') {
                    e.preventDefault();
                    togglePlay();
                }
                
                // ARROWS: Frame-by-frame navigation
                if (e.code === 'ArrowLeft' && !e.shiftKey) {
                    e.preventDefault();
                    if (isImage) {
                         setCurrentTime(t => Math.max(0, t - 0.1));
                    } else if (videoRef.current) {
                         videoRef.current.currentTime = Math.max(0, videoRef.current.currentTime - 0.1);
                    }
                }
                if (e.code === 'ArrowRight' && !e.shiftKey) {
                    e.preventDefault();
                     if (isImage) {
                         setCurrentTime(t => Math.min(duration, t + 0.1));
                    } else if (videoRef.current) {
                         videoRef.current.currentTime = Math.min(duration, videoRef.current.currentTime + 0.1);
                    }
                }

                if (e.code === 'Delete' || e.code === 'Backspace') {
                    if (mode === 'graph' && selectedNodeId) {
                        setNodeToDelete(selectedNodeId);
                        setShowDeleteModal(true);
                    } else if (mode === 'edit' && selectedOptionId && activeNode) {
                        saveHistory();
                        const newOptions = activeNode.options.filter(o => o.id !== selectedOptionId);
                        updateNode(activeNode.id, 'options', newOptions);
                        setSelectedOptionId(null);
                    }
                }
                
                if (mode === 'edit' && selectedOptionId && activeNode && e.shiftKey) {
                    const opt = activeNode.options.find(o => o.id === selectedOptionId);
                    if (opt) {
                        e.preventDefault();
                        saveHistory();
                        const step = 0.5; 
                        let newLeft = opt.style.left;
                        let newTop = opt.style.top;
                        if (e.code === 'ArrowLeft') newLeft -= step;
                        if (e.code === 'ArrowRight') newLeft += step;
                        if (e.code === 'ArrowUp') newTop -= step;
                        if (e.code === 'ArrowDown') newTop += step;
                        newLeft = Math.max(0, Math.min(100, newLeft));
                        newTop = Math.max(0, Math.min(100, newTop));
                        
                        if(opt.useKeyframes) {
                            addKeyframe(opt, {left: newLeft, top: newTop});
                        } else {
                            const updatedOptions = activeNode.options.map(o => o.id === selectedOptionId ? { ...o, style: { ...o.style, left: newLeft, top: newTop } } : o);
                            updateNode(activeNode.id, 'options', updatedOptions);
                        }
                    }
                }
            };
            window.addEventListener('keydown', handleKeyDown);
            return () => window.removeEventListener('keydown', handleKeyDown);
          }, [mode, selectedNodeId, selectedOptionId, activeNode, undo, redo, nodes, variables, startNodeId, duration, isImage, togglePlay]);


          // --- Reset & Transition Logic ---
          useEffect(() => {
            setVideoError(null);
            setShowMissingFilesModal(false);
            if (mode === 'preview') {
                if (isTransitioning) {
                    const timer = setTimeout(() => setIsTransitioning(false), 100);
                    return () => clearTimeout(timer);
                }
            } else {
                setIsTransitioning(false);
            }
          }, [activeNodeId, mode]);

          // --- MEDIA LOADING EFFECT (FIXED) ---
          useEffect(() => {
            if (isImage) {
                // Image handling
                setDuration(10); // Default duration for images
                setVideoError(null);
                setShowMissingFilesModal(false);
                setIsPlaying(true); // AUTOPLAY ON IMAGE LOAD
                setCurrentTime(0);
            } else if (videoRef.current && !youtubeId) {
                // Video handling
                // We ONLY call load if the source effectively changed or we just mounted
                videoRef.current.load();
                if (mode === 'preview') {
                    videoRef.current.play().catch(e => console.log("Autoplay blocked", e));
                    setIsPlaying(true);
                } else {
                    setIsPlaying(false);
                }
                setCurrentTime(0);
            }
          }, [activeNodeId, mode, activeNode?.videoUrl, fileBlobs, youtubeId, isImage]); 
          // CRITICAL FIX: Removed `activeNode` object from deps to prevent reload on drag.

          // --- VARIABLES SYSTEM ---
          const addVariable = () => {
            saveHistory();
            setVariables([...variables, { name: `var_${variables.length}`, type: 'number', value: 0 }]);
          };
          const updateVariable = (idx, field, val) => {
            saveHistory();
            const newVars = [...variables];
            newVars[idx][field] = val;
            setVariables(newVars);
          };
          const removeVariable = (idx) => {
            saveHistory();
            const newVars = variables.filter((_, i) => i !== idx);
            setVariables(newVars);
          };
          const checkCondition = (condition) => {
            if (!condition || !condition.variable) return true;
            const currentVal = runtimeVariables[condition.variable];
            const targetVal = parseFloat(condition.value);
            switch (condition.operator) {
              case 'eq': return currentVal == targetVal;
              case 'neq': return currentVal != targetVal;
              case 'gt': return currentVal > targetVal;
              case 'lt': return currentVal < targetVal;
              default: return true;
            }
          };
          const applyEffects = (effects) => {
            if (!effects) return;
            const newRuntime = { ...runtimeVariables };
            effects.forEach(eff => {
                if (!eff.variable) return;
                const currentVal = newRuntime[eff.variable] || 0;
                const effectVal = parseFloat(eff.value);
                if (eff.operator === 'set') newRuntime[eff.variable] = effectVal;
                if (eff.operator === 'add') newRuntime[eff.variable] = currentVal + effectVal;
                if (eff.operator === 'sub') newRuntime[eff.variable] = currentVal - effectVal;
            });
            setRuntimeVariables(newRuntime);
          };

          // --- SAVE & LOAD ---
          const handleSaveProject = () => {
            const projectData = { version: '2.0', timestamp: Date.now(), startNodeId, nodes, variables };
            const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `intervideo-project-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
          };
          const handleLoadProject = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
              try {
                const data = JSON.parse(event.target.result);
                if (data.nodes) {
                  saveHistory();
                  setNodes(data.nodes);
                  if (data.startNodeId) setStartNodeId(data.startNodeId);
                  if (data.variables) setVariables(data.variables);
                  setSelectedNodeId(data.startNodeId || (data.nodes.length > 0 ? data.nodes[0].id : null));
                  setShowLoadModal(false);
                  alert("Projecte carregat!");
                }
              } catch (err) { alert("Error JSON"); }
            };
            reader.readAsText(file);
            e.target.value = ''; 
          };
          const handleExportZip = async () => {
            try {
              const JSZip = await loadJSZip();
              const zip = new JSZip();
              const projectData = { version: '2.0', startNodeId, nodes, variables };
              zip.file("project.json", JSON.stringify(projectData, null, 2));
              
              const viewerContent = `<!DOCTYPE html><html lang="ca"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><title>Visualitzador</title><style>body{background:#000;margin:0;overflow:hidden;font-family:sans-serif}#container{position:relative;width:100vw;height:100vh;display:flex;justify-content:center;background:black}video,iframe,img{width:100%;height:100%;object-fit:contain}.btn{position:absolute;transform:translate(-50%,-50%);cursor:pointer;display:none;opacity:0;transition:opacity 0.5s,transform 0.2s}.btn.visible{display:flex;opacity:1}.btn:hover{transform:translate(-50%,-50%)scale(1.05)}.fade-overlay{position:absolute;inset:0;background:black;opacity:0;pointer-events:none;transition:opacity 0.5s;z-index:100}.fade-overlay.active{opacity:1;pointer-events:auto}.hotspot-tooltip{position:absolute;background:rgba(0,0,0,0.8);color:white;padding:4px 8px;border-radius:4px;font-size:12px;pointer-events:none;white-space:nowrap;z-index:101;transform:translate(-50%,-100%);margin-top:-8px}</style></head><body><div id="container"></div><script>/* Lògica del reproductor */ alert("Utilitza un visualitzador complet (index.html).");<\/script></body></html>`;
              zip.file("index.html", viewerContent);
              zip.folder("videos");
              zip.file("LLEGEIX-ME.txt", "Posa els teus fitxers de vídeo a la carpeta 'videos'.");
              const content = await zip.generateAsync({ type: "blob" });
              const url = URL.createObjectURL(content);
              const a = document.createElement('a');
              a.href = url;
              a.download = "intervideo-export.zip";
              a.click();
              URL.revokeObjectURL(url);
            } catch (err) { alert("Error generant ZIP: " + err); }
          };
          const handleLoadProjectVideos = (e) => {
            const files = Array.from(e.target.files);
            const newBlobs = {};
            let count = 0;
            files.forEach(file => {
                 // Accept video and image types
                if (file.type.startsWith('video/') || file.type.startsWith('image/')) {
                    const relativeKey = `videos/${file.name}`;
                    newBlobs[relativeKey] = URL.createObjectURL(file);
                    count++;
                }
            });
            setFileBlobs(prev => ({ ...prev, ...newBlobs }));
            setVideosLoadedCount(count);
            if (showMissingFilesModal) { setShowMissingFilesModal(false); setVideoError(null); }
            e.target.value = '';
          };

          // --- CRUD & Helpers ---
          const addNode = () => {
            saveHistory();
            const newId = `escena-${Date.now()}`;
            const newNode = {
              id: newId,
              title: 'Nova Escena',
              videoUrl: '', 
              position: { x: 300 + (nodes.length * 20), y: 300 + (nodes.length * 20) }, 
              color: '#6b7280',
              transitionType: 'none', 
              options: []
            };
            setNodes([...nodes, newNode]);
            setSelectedNodeId(newId);
            if (nodes.length === 0) setStartNodeId(newId); 
          };
          const updateNode = (id, field, value) => {
              setNodes(nodes.map(n => n.id === id ? { ...n, [field]: value } : n));
          };
          const deleteNode = (id) => { setNodeToDelete(id); setShowDeleteModal(true); };
          const confirmDeleteNode = () => {
            if (!nodeToDelete) return;
            saveHistory();
            const newNodes = nodes.filter(n => n.id !== nodeToDelete);
            setNodes(newNodes);
            if (selectedNodeId === nodeToDelete) setSelectedNodeId(newNodes.length > 0 ? newNodes[0].id : null);
            if (startNodeId === nodeToDelete) setStartNodeId(newNodes.length > 0 ? newNodes[0].id : null); 
            setShowDeleteModal(false); setNodeToDelete(null);
          };
          const handleFileUpload = (e) => {
            const file = e.target.files[0];
            if (file && activeNode) {
              saveHistory();
              const blobUrl = URL.createObjectURL(file);
              const relativePath = `videos/${file.name}`;
              setFileBlobs(prev => ({...prev, [relativePath]: blobUrl}));
              updateNode(activeNode.id, 'videoUrl', relativePath);
            }
          };
          const addOption = () => {
            if (!activeNode) return;
            saveHistory();
            let initialStyle = { top: 50, left: 50, width: 150, height: 50, fontSize: 14, color: '#ffffff', backgroundColor: activeNode.color || '#6366f1', bgOpacity: 1, padding: 10, borderRadius: 6, fontFamily: 'sans-serif' };
            if (clipboardStyle) initialStyle = { ...initialStyle, ...clipboardStyle };
            const newOption = {
              id: `opt-${Date.now()}`,
              label: 'Opció Nova',
              targetNodeId: nodes.length > 0 ? nodes[0].id : activeNode.id,
              startTime: Math.floor(currentTime),
              endTime: duration || Math.floor(currentTime) + 10,
              singleUse: false,
              isHotspot: false, 
              hoverText: '',    
              useKeyframes: false, 
              keyframes: [],    
              condition: null, 
              effects: [], 
              style: initialStyle
            };
            updateNode(activeNode.id, 'options', [...activeNode.options, newOption]);
          };
          const updateOption = (optionId, field, value) => {
            const updatedOptions = activeNode.options.map(opt => opt.id === optionId ? { ...opt, [field]: value } : opt);
            updateNode(activeNode.id, 'options', updatedOptions);
          };
          const batchUpdateOptionStyles = (optionId, newStyles) => {
            const updatedOptions = activeNode.options.map(opt => opt.id === optionId ? { ...opt, style: { ...opt.style, ...newStyles } } : opt);
            updateNode(activeNode.id, 'options', updatedOptions);
          };
          const batchUpdateOptionFields = (optionId, newFields) => {
            const updatedOptions = activeNode.options.map(opt => opt.id === optionId ? { ...opt, ...newFields } : opt);
            updateNode(activeNode.id, 'options', updatedOptions);
          };
          const updateOptionStyle = (optionId, styleField, value) => {
            const updatedOptions = activeNode.options.map(opt => opt.id === optionId ? { ...opt, style: { ...opt.style, [styleField]: value } } : opt);
            updateNode(activeNode.id, 'options', updatedOptions);
          };
          const handleCopyStyle = (sourceStyle) => setClipboardStyle({ ...sourceStyle });
          const handlePasteStyle = (targetOptionId) => {
              if (clipboardStyle) {
                  saveHistory();
                  batchUpdateOptionStyles(targetOptionId, clipboardStyle);
              }
          };
          const removeOption = (optionId) => {
              saveHistory();
              updateNode(activeNode.id, 'options', activeNode.options.filter(opt => opt.id !== optionId));
          };

          // --- KEYFRAME LOGIC ---
          const addKeyframe = (opt, coords) => {
              // Si no passem coords, usem actual
              const left = coords ? coords.left : opt.style.left;
              const top = coords ? coords.top : opt.style.top;
              const width = coords ? coords.width : opt.style.width; 
              const height = coords ? coords.height : opt.style.height; 
              
              const newKeyframe = { time: currentTime, left, top, width, height };
              const existing = opt.keyframes || [];
              const filtered = existing.filter(k => Math.abs(k.time - currentTime) > 0.1);
              updateOption(opt.id, 'keyframes', [...filtered, newKeyframe].sort((a,b) => a.time - b.time));
          };
          
          const deleteKeyframe = (optId, time) => {
              saveHistory();
              const opt = activeNode.options.find(o => o.id === optId);
              if(!opt) return;
              const newKeyframes = (opt.keyframes || []).filter(k => Math.abs(k.time - time) > 0.01);
              updateOption(optId, 'keyframes', newKeyframes);
          };
          
          const seekToKeyframe = (time) => {
              setCurrentTime(time);
              if (videoRef.current) videoRef.current.currentTime = time;
          };

          // --- INTERACTION ---
          const handleOptionInteraction = (opt) => {
            if (mode === 'preview') {
                if (opt.singleUse) setClickedOptions(prev => new Set(prev).add(opt.id));
                if (opt.effects) applyEffects(opt.effects);
                const targetNode = nodes.find(n => n.id === opt.targetNodeId);
                if (targetNode?.transitionType === 'fade') {
                    setIsTransitioning(true);
                    setTimeout(() => { setCurrentNodeId(opt.targetNodeId); }, 500);
                } else {
                    setCurrentNodeId(opt.targetNodeId);
                }
            }
          };

          // --- DRAG ---
          const handleButtonMouseDown = (e, opt) => {
            if (mode !== 'edit') return;
            e.stopPropagation(); e.preventDefault();
            setSelectedOptionId(opt.id); 
            saveHistory();
            setDragState({ isDragging: true, type: 'move', targetId: opt.id, startX: e.clientX, startY: e.clientY, initialVal: { left: parseFloat(opt.style.left) || 0, top: parseFloat(opt.style.top) || 0 } });
          };
          const handleResizeMouseDown = (e, opt) => {
            if (mode !== 'edit') return;
            e.stopPropagation(); e.preventDefault();
            saveHistory();
            setDragState({ isDragging: true, type: 'resize', targetId: opt.id, startX: e.clientX, startY: e.clientY, initialVal: { width: parseFloat(opt.style.width) || 100, height: parseFloat(opt.style.height) || 50 } });
          };
          const handleTimelineItemMouseDown = (e, opt, type) => {
            if (mode !== 'edit') return;
            e.stopPropagation(); e.preventDefault();
            saveHistory();
            setDragState({ isDragging: true, type: type, targetId: opt.id, startX: e.clientX, initialVal: { startTime: opt.startTime, endTime: opt.endTime || duration } });
          };
          const handleGlobalMouseMove = useCallback((e) => {
            if (!dragState.isDragging || !activeNode) return;
            if (dragState.type === 'move') {
              const rect = videoContainerRef.current?.getBoundingClientRect();
              if (!rect) return;
              const deltaX = e.clientX - dragState.startX;
              const deltaY = e.clientY - dragState.startY;
              
              const newLeft = Math.max(0, Math.min(100, dragState.initialVal.left + (deltaX / rect.width) * 100));
              const newTop = Math.max(0, Math.min(100, dragState.initialVal.top + (deltaY / rect.height) * 100));

              batchUpdateOptionStyles(dragState.targetId, { left: newLeft, top: newTop });
            }
            if (dragState.type === 'resize') {
              batchUpdateOptionStyles(dragState.targetId, { 
                  width: Math.max(20, dragState.initialVal.width + (e.clientX - dragState.startX)), 
                  height: Math.max(20, dragState.initialVal.height + (e.clientY - dragState.startY)) 
              });
            }
            if (['timeline-move', 'timeline-start', 'timeline-end'].includes(dragState.type)) {
              const rect = timelineTrackRef.current?.getBoundingClientRect();
              if (!rect || duration === 0) return;
              const deltaSeconds = ((e.clientX - dragState.startX) / rect.width) * duration;
              const opt = activeNode.options.find(o => o.id === dragState.targetId);
              if (!opt) return;
              if (dragState.type === 'timeline-move') {
                const span = dragState.initialVal.endTime - dragState.initialVal.startTime;
                let start = Math.max(0, dragState.initialVal.startTime + deltaSeconds);
                let end = start + span;
                if (end > duration) { end = duration; start = duration - span; }
                batchUpdateOptionFields(opt.id, { startTime: start, endTime: end });
              } else if (dragState.type === 'timeline-start') {
                let start = Math.max(0, dragState.initialVal.startTime + deltaSeconds);
                if (start >= dragState.initialVal.endTime - 0.5) start = dragState.initialVal.endTime - 0.5;
                batchUpdateOptionFields(opt.id, { startTime: start });
              } else if (dragState.type === 'timeline-end') {
                let end = Math.min(duration, dragState.initialVal.endTime + deltaSeconds);
                if (end <= dragState.initialVal.startTime + 0.5) end = dragState.initialVal.startTime + 0.5;
                batchUpdateOptionFields(opt.id, { endTime: end });
              }
            }
          }, [dragState, activeNode, duration]);

          const handleGlobalMouseUp = useCallback(() => {
              // SAVE KEYFRAME ON DROP/RESIZE if using keyframes
              if (dragState.isDragging && (dragState.type === 'move' || dragState.type === 'resize') && activeNode) {
                  const opt = activeNode.options.find(o => o.id === dragState.targetId);
                  if (opt && opt.useKeyframes) {
                      addKeyframe(opt);
                  }
              }
              setDragState({ isDragging: false, type: null });
          }, [dragState, activeNode, currentTime]);

          useEffect(() => {
            if (dragState.isDragging) { window.addEventListener('mousemove', handleGlobalMouseMove); window.addEventListener('mouseup', handleGlobalMouseUp); }
            return () => { window.removeEventListener('mousemove', handleGlobalMouseMove); window.removeEventListener('mouseup', handleGlobalMouseUp); };
          }, [dragState, handleGlobalMouseMove, handleGlobalMouseUp]);

          const handleTimelineClick = (e) => {
            if (dragState.isDragging || youtubeId) return;
            const rect = timelineTrackRef.current?.getBoundingClientRect();
            if (!rect) return;
            const newTime = ((e.clientX - rect.left) / rect.width) * duration;
            if (isFinite(newTime)) { setCurrentTime(newTime); if (videoRef.current) videoRef.current.currentTime = newTime; }
          };

          // --- RENDER ---
          return (
            <div className="flex flex-col h-screen bg-gray-900 text-gray-100 font-sans overflow-hidden relative">
              {/* HEADER */}
              <header className="h-14 bg-gray-800 border-b border-gray-700 flex items-center justify-between px-4 shrink-0 z-20">
                <div className="flex flex-col">
                    <div className="flex items-center gap-2"><MonitorPlay className="text-blue-500 w-6 h-6" /><h1 className="font-bold text-lg">Editor de Video Interactiu</h1></div>
                    <span className="text-[10px] text-gray-500 ml-8 -mt-1">Una aplicació de Xavier Ribes - GameLab de la UAB</span>
                </div>
                <div className="flex items-center gap-3">
                    <button onClick={undo} className="p-2 text-gray-400 hover:text-white rounded" title="Desfer (Ctrl+Z)"><Undo size={16}/></button>
                    <button onClick={redo} className="p-2 text-gray-400 hover:text-white rounded" title="Refer (Ctrl+Y)"><Redo size={16}/></button>
                    <button onClick={() => setShowVariablesModal(true)} className="p-2 text-gray-300 hover:text-white hover:bg-gray-700 rounded transition-colors flex items-center gap-2 text-sm"><Database size={16} /> Variables</button>
                    <div className="flex bg-gray-900 rounded-lg p-1 border border-gray-700 mr-2 gap-1">
                        <button onClick={() => setShowLoadModal(true)} className="p-1.5 text-gray-400 hover:text-white hover:bg-gray-700 rounded transition-colors" title="Carregar Projecte"><FolderOpen size={16} /></button>
                        <button onClick={handleSaveProject} className="p-1.5 text-gray-400 hover:text-white hover:bg-gray-700 rounded transition-colors" title="Desar Projecte"><Save size={16} /></button>
                        <button onClick={handleExportZip} className="p-1.5 text-gray-400 hover:text-blue-400 hover:bg-gray-700 rounded transition-colors" title="Exportar ZIP (Web)"><Package size={16} /></button>
                        <input type="file" ref={projectInputRef} onChange={handleLoadProject} accept=".json" className="hidden" />
                        <input type="file" ref={bulkVideoInputRef} onChange={handleLoadProjectVideos} webkitdirectory="true" directory="" multiple className="hidden" />
                    </div>
                    <div className="flex bg-gray-900 rounded-lg p-1 border border-gray-700">
                        <button onClick={() => { setMode('edit'); setIsPlaying(false); }} className={`px-4 py-1.5 rounded-md text-sm font-medium ${mode === 'edit' ? 'bg-blue-600 text-white' : 'text-gray-400'}`}>Editor</button>
                        <button onClick={() => setMode('graph')} className={`px-4 py-1.5 rounded-md text-sm font-medium ${mode === 'graph' ? 'bg-purple-600 text-white' : 'text-gray-400'}`}>Mapa</button>
                        <button onClick={() => { 
                            if (nodes.length > 0) { 
                                const startId = startNodeId || nodes[0].id;
                                const startNode = nodes.find(n => n.id === startId);
                                if (startNode?.transitionType === 'fade') setIsTransitioning(true); 
                                setMode('preview'); setCurrentNodeId(startId); setClickedOptions(new Set()); 
                                setRuntimeVariables(variables.reduce((acc, v) => ({ ...acc, [v.name]: v.value }), {})); 
                            } else alert("Crea almenys una escena.");
                        }} className={`px-4 py-1.5 rounded-md text-sm font-medium ${mode === 'preview' ? 'bg-green-600 text-white' : 'text-gray-400'}`}>Previsualitzar</button>
                    </div>
                </div>
              </header>

              <div className="flex flex-1 overflow-hidden relative">
                {mode === 'graph' ? (
                   <div className="flex-1 flex flex-col relative">
                     <div className="absolute top-4 left-4 z-20"><button onClick={addNode} className="bg-blue-600 text-white px-4 py-2 rounded flex items-center gap-2"><Plus size={16} /> Nova Escena</button></div>
                     <NodeGraph nodes={nodes} onUpdateNode={updateNode} onSelectNode={(id) => { setSelectedNodeId(id); setMode('edit'); }} onDeleteNode={deleteNode} startNodeId={startNodeId} onSetStartNode={setStartNodeId} onPreviewNode={(id) => { setCurrentNodeId(id); setMode('preview'); setClickedOptions(new Set()); }}/>
                   </div>
                ) : (
                  <>
                    {mode === 'edit' && (
                      <aside className="w-56 bg-gray-800 border-r border-gray-700 flex flex-col shrink-0">
                        <div className="p-4 border-b border-gray-700 flex justify-between items-center">
                            <h2 className="font-semibold text-gray-300">Escenes</h2>
                            <button onClick={addNode} className="text-blue-400 hover:text-blue-300"><Plus size={20} /></button>
                        </div>
                        <div className="flex-1 overflow-y-auto p-2 space-y-2">
                          {nodes.map(node => (
                            <div key={node.id} onClick={() => setSelectedNodeId(node.id)} className={`p-3 rounded-lg cursor-pointer border-l-4 ${selectedNodeId === node.id ? 'bg-blue-900/50 ring-1 ring-blue-500/50' : 'bg-gray-800 border-transparent hover:bg-gray-700'}`} style={{ borderLeftColor: node.color }}>
                              <h3 className="font-medium text-sm text-gray-200">{node.title}</h3>
                              {startNodeId === node.id && <span className="text-[10px] text-green-500 font-mono">★ INICI</span>}
                            </div>
                          ))}
                        </div>
                      </aside>
                    )}

                    <main className="flex-1 flex flex-col bg-gray-950 relative min-w-0">
                      <div ref={videoContainerRef} onClick={() => mode === 'edit' && setSelectedOptionId(null)} className={`relative flex-1 bg-black flex items-center justify-center overflow-hidden ${mode === 'edit' ? 'select-none' : ''}`}>
                        {!activeNode ? (
                            <div className="text-gray-500 text-center"><Film size={64} className="mb-4 opacity-20 mx-auto"/><p>Selecciona una escena</p></div>
                        ) : youtubeId ? (
                            <iframe src={`https://www.youtube.com/embed/${youtubeId}?rel=0&controls=1&autoplay=0`} className="w-full h-full" frameBorder="0" allowFullScreen></iframe>
                        ) : isImage ? (
                             <img src={fileBlobs[activeNode.videoUrl] || getVideoSrc(activeNode.videoUrl)} className="w-full h-full object-contain" />
                        ) : activeNode.videoUrl ? (
                          <video 
                            ref={videoRef} className="w-full h-full object-contain" 
                            src={fileBlobs[activeNode.videoUrl] || getVideoSrc(activeNode.videoUrl)} 
                            onClick={mode === 'preview' ? togglePlay : null} loop={mode === 'edit'} playsInline preload="auto"
                          />
                        ) : <div className="text-center text-gray-500"><ImageIcon className="w-16 h-16 mx-auto mb-4 opacity-50" /><button onClick={() => fileInputRef.current?.click()} className="text-blue-400 underline">Carregar Mèdia</button></div>}

                        {/* TRANSITION OVERLAY */}
                        <div className={`absolute inset-0 bg-black pointer-events-none transition-opacity duration-500 z-[100] ${isTransitioning ? 'opacity-100' : 'opacity-0'}`}></div>

                        {videoError && activeNode && !showMissingFilesModal && !youtubeId && (
                            <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/80 text-red-400 z-50"><AlertCircle size={48} className="mb-2"/><p>{videoError}</p></div>
                        )}

                        <div className="absolute inset-0 pointer-events-none">
                          {activeNode && activeNode.options.map(opt => {
                            const isVisible = youtubeId ? true : (currentTime >= opt.startTime && currentTime <= (opt.endTime || duration));
                            let conditionsMet = true;
                            if (mode === 'preview' && opt.condition && opt.condition.variable) {
                                conditionsMet = checkCondition(opt.condition);
                            }
                            if (mode === 'preview' && opt.singleUse && clickedOptions.has(opt.id)) conditionsMet = false;

                            const shouldShow = mode === 'edit' ? true : (isVisible && conditionsMet);
                            const opacity = (mode === 'edit' && !isVisible) ? 0.3 : 1;
                            if (!shouldShow) return null;
                            const isSelected = dragState.targetId === opt.id || selectedOptionId === opt.id;
                            
                            // CALCULATE POSITION
                            let currentStyle = opt.style;
                            if (opt.useKeyframes && isPlaying && mode === 'preview') {
                                currentStyle = getInterpolatedStyle(opt, currentTime);
                            } else if (opt.useKeyframes && mode === 'edit') {
                                // En edit, si estem arrossegant, ja veiem la posició de l'estil actual (actualitzat per globalMove)
                                // Si NO estem arrossegant, mostrem la interpolada per al temps actual
                                if (!(dragState.isDragging && dragState.targetId === opt.id)) {
                                    currentStyle = getInterpolatedStyle(opt, currentTime);
                                }
                            }

                            const finalBgColor = hexToRgba(currentStyle.backgroundColor, currentStyle.bgOpacity !== undefined ? currentStyle.bgOpacity : 1);
                            
                            const isHotspotInvisible = mode === 'preview' && opt.isHotspot;
                            const displayOpacity = isHotspotInvisible ? 0 : 1;
                            const hotspotBorder = (mode === 'edit' && opt.isHotspot) ? '2px dashed rgba(255,255,255,0.5)' : 'none';

                            return (
                              <div 
                                key={opt.id} 
                                className={`absolute pointer-events-auto group transition-opacity duration-500 ${shouldShow ? 'opacity-100' : 'opacity-0'}`} 
                                style={{ top: `${currentStyle.top}%`, left: `${currentStyle.left}%`, width: currentStyle.width, height: currentStyle.height, transform: 'translate(-50%, -50%)', opacity: opacity * displayOpacity }}
                                onMouseEnter={() => setHoveredOptionId(opt.id)}
                                onMouseLeave={() => setHoveredOptionId(null)}
                              >
                                 <button onMouseDown={(e) => handleButtonMouseDown(e, opt)} onClick={() => handleOptionInteraction(opt)}
                                    className={`w-full h-full flex items-center justify-center text-center overflow-hidden transition-transform relative 
                                    ${mode === 'edit' ? 'cursor-move' : 'hover:scale-105 cursor-pointer'}
                                    ${isSelected ? 'ring-2 ring-yellow-400 shadow-2xl z-50' : ''}
                                    `}
                                    style={{ 
                                        fontSize: `${currentStyle.fontSize}px`, 
                                        color: currentStyle.color, 
                                        backgroundColor: finalBgColor, 
                                        padding: `${currentStyle.padding}px`, 
                                        borderRadius: currentStyle.borderRadius, 
                                        fontFamily: currentStyle.fontFamily,
                                        border: isSelected ? undefined : hotspotBorder
                                    }}>
                                    {mode === 'edit' && opt.singleUse && (<div className="absolute top-1 right-1 opacity-70"><Ghost size={12} className="text-white drop-shadow-md"/></div>)}
                                    {!opt.isHotspot && opt.label} 
                                  </button>
                                  
                                  {mode === 'preview' && hoveredOptionId === opt.id && opt.hoverText && (
                                      <div className="hotspot-tooltip">{opt.hoverText}</div>
                                  )}

                                  {mode === 'edit' && (<div onMouseDown={(e) => handleResizeMouseDown(e, opt)} className="absolute bottom-0 right-0 w-4 h-4 bg-blue-500 cursor-nwse-resize z-50 opacity-0 group-hover:opacity-100 rounded-tl" />)}
                              </div>
                            );
                          })}
                        </div>
                      </div>

                      {mode === 'edit' && activeNode && !youtubeId && (
                        <div className="h-48 bg-gray-900 border-t border-gray-700 flex flex-col shrink-0 select-none">
                           <div className="h-10 bg-gray-800 border-b border-gray-700 flex items-center px-4 gap-4 justify-between">
                              <div className="flex items-center gap-4"><button onClick={togglePlay} className="text-white hover:text-blue-400">{isPlaying ? <Pause size={16}/> : <Play size={16}/>}</button><span className="text-xs font-mono text-gray-300 w-24">{currentTime.toFixed(2)}s / {duration.toFixed(2)}s</span></div>
                           </div>
                           <div className="flex-1 flex flex-col min-h-0 bg-gray-900 relative">
                              <div className="absolute inset-0 flex justify-between px-4 pointer-events-none opacity-10">{[...Array(11)].map((_, i) => <div key={i} className="h-full w-px bg-white"></div>)}</div>
                              <div ref={timelineTrackRef} className="h-6 w-full bg-gray-800 border-b border-gray-700 relative cursor-pointer px-4 box-border shrink-0 z-10" onClick={handleTimelineClick}>
                                 <div className="absolute top-0 bottom-0 w-0.5 bg-red-500 z-10 pointer-events-none" style={{ left: `${(currentTime / duration) * 100}%`, marginLeft: '16px' }}></div>
                              </div>
                              <div className="flex-1 overflow-y-auto p-2 px-4 relative z-0">
                                  {activeNode.options.map((opt, idx) => {
                                      const leftPct = (opt.startTime / duration) * 100;
                                      const widthPct = ((opt.endTime - opt.startTime) / duration) * 100;
                                      const isSelected = selectedOptionId === opt.id;
                                      return (
                                          <div key={opt.id} onClick={(e) => { e.stopPropagation(); setSelectedOptionId(opt.id); }} className={`h-8 relative w-full bg-gray-800/50 rounded mb-1 border ${isSelected ? 'border-yellow-500' : 'border-gray-700/50'}`}>
                                              <div className="absolute left-2 top-0 bottom-0 flex items-center text-[10px] text-gray-600 pointer-events-none z-0 w-32 truncate select-none">{opt.label}</div>
                                              
                                              {opt.useKeyframes && opt.keyframes && opt.keyframes.map((kf, ki) => {
                                                  const isCurrent = Math.abs(kf.time - currentTime) < 0.1;
                                                  return (
                                                      <div 
                                                          key={ki} 
                                                          onClick={(e) => { e.stopPropagation(); seekToKeyframe(kf.time); }}
                                                          className={`absolute top-1/2 w-2 h-2 transform -translate-x-1/2 -translate-y-1/2 rotate-45 z-30 cursor-pointer ${isCurrent ? 'bg-red-500 scale-125' : 'bg-orange-400 hover:bg-orange-300'}`} 
                                                          style={{ left: `${(kf.time / duration) * 100}%` }} 
                                                          title={`Keyframe: ${kf.time.toFixed(1)}s`}
                                                      ></div>
                                                  );
                                              })}

                                              <div className="absolute top-1 bottom-1 bg-blue-600/60 border border-blue-400 rounded cursor-pointer group flex items-center justify-between px-1 hover:bg-blue-600/80 z-10" style={{ left: `${leftPct}%`, width: `${widthPct}%` }} onMouseDown={(e) => handleTimelineItemMouseDown(e, opt, 'timeline-move')}>
                                                  <div className="w-2 h-full bg-blue-400/30 cursor-w-resize hover:bg-white z-20 shrink-0" onMouseDown={(e) => handleTimelineItemMouseDown(e, opt, 'timeline-start')}></div>
                                                  <span className="text-[10px] text-white font-mono drop-shadow-md truncate pointer-events-none select-none px-1 min-w-0 flex-1 text-center flex items-center justify-center gap-1">{opt.singleUse && <Ghost size={8}/>}{opt.label}</span>
                                                  <div className="w-2 h-full bg-blue-400/30 cursor-e-resize hover:bg-white z-20 shrink-0" onMouseDown={(e) => handleTimelineItemMouseDown(e, opt, 'timeline-end')}></div>
                                              </div>
                                          </div>
                                      );
                                  })}
                              </div>
                           </div>
                        </div>
                      )}
                    </main>

                    {/* INSPECTOR */}
                    {mode === 'edit' && activeNode && (
                      <aside className="w-80 bg-gray-800 border-l border-gray-700 flex flex-col shrink-0 overflow-hidden">
                        <div className="flex border-b border-gray-700">
                            <button onClick={() => setActiveTab('properties')} className={`flex-1 py-2 text-xs font-bold ${activeTab === 'properties' ? 'text-blue-400 border-b-2 border-blue-400 bg-gray-750' : 'text-gray-400 hover:bg-gray-700'}`}>ESCENA</button>
                            <button onClick={() => setActiveTab('interactions')} className={`flex-1 py-2 text-xs font-bold ${activeTab === 'interactions' ? 'text-blue-400 border-b-2 border-blue-400 bg-gray-750' : 'text-gray-400 hover:bg-gray-700'}`}>INTERACCIONS</button>
                        </div>
                        
                        <div className="flex-1 overflow-y-auto p-4 space-y-4">
                          {activeTab === 'properties' && (
                              <>
                                <div><label className="block text-xs font-medium text-gray-500 uppercase mb-1">Títol</label><input type="text" value={activeNode.title} onChange={(e) => updateNode(activeNode.id, 'title', e.target.value)} className="w-full bg-gray-900 border border-gray-600 rounded px-2 py-1 text-sm outline-none"/></div>
                                <div>
                                    <label className="block text-xs font-medium text-gray-500 uppercase mb-1">Vídeo / Imatge</label>
                                    <input type="text" value={activeNode.videoUrl} onChange={(e) => updateNode(activeNode.id, 'videoUrl', e.target.value)} className="w-full bg-gray-900 border border-gray-600 rounded px-2 py-1 text-xs mb-2 font-mono"/>
                                    <input type="file" ref={fileInputRef} onChange={handleFileUpload} accept="video/*,image/*" className="hidden" />
                                    <button onClick={() => fileInputRef.current?.click()} className="w-full bg-gray-700 hover:bg-gray-600 text-xs py-1 rounded flex items-center justify-center gap-2 border border-gray-600"><Upload size={12} /> Pujar Local</button>
                                </div>
                                <div><label className="block text-xs font-medium text-gray-500 uppercase mb-1">Transició d'Entrada</label><select value={activeNode.transitionType || 'none'} onChange={(e) => updateNode(activeNode.id, 'transitionType', e.target.value)} className="w-full bg-gray-900 border border-gray-600 rounded px-2 py-1 text-sm"><option value="none">Cap (Tall sec)</option><option value="fade">Fosa a Negre</option></select></div>
                              </>
                          )}

                          {activeTab === 'interactions' && (
                              <>
                                <div className="flex justify-between items-center mb-2"><h3 className="text-sm font-semibold text-gray-300">Botons</h3><button onClick={addOption} className="text-xs bg-blue-600 px-2 py-1 rounded text-white"><Plus size={12}/></button></div>
                                <div className="space-y-4">
                                    {activeNode.options.map((opt, idx) => (
                                        <div key={opt.id} onClick={() => setSelectedOptionId(opt.id)} className={`bg-gray-750 border rounded p-2 ${selectedOptionId === opt.id ? 'border-yellow-500' : 'border-gray-600'}`}>
                                            <div className="flex justify-between items-center mb-2">
                                                <span className="text-xs font-bold text-gray-400">Botó #{idx + 1}</span>
                                                <div className="flex gap-1"><button onClick={(e) => { e.preventDefault(); handleCopyStyle(opt.style); }} className="p-1 hover:bg-gray-600 rounded text-gray-400" title="Copiar Estil"><Copy size={12}/></button>{clipboardStyle && (<button onClick={(e) => { e.preventDefault(); handlePasteStyle(opt.id); }} className="p-1 hover:bg-gray-600 rounded text-green-400" title="Enganxar Estil"><Clipboard size={12}/></button>)}<button onClick={() => removeOption(opt.id)} className="text-red-400"><Trash2 size={12}/></button></div>
                                            </div>
                                            <input type="text" value={opt.label} onChange={(e) => updateOption(opt.id, 'label', e.target.value)} className="bg-gray-900 border border-gray-600 rounded px-2 py-1 text-sm w-full mb-2" placeholder="Etiqueta"/>
                                            {/* FILTERED SELECT */}
                                            <select value={opt.targetNodeId} onChange={(e) => updateOption(opt.id, 'targetNodeId', e.target.value)} className="bg-gray-900 border border-gray-600 rounded px-2 py-1 text-sm w-full mb-2">
                                                {nodes.filter(n => n.id !== activeNode.id).map(n => <option key={n.id} value={n.id}>➔ {n.title}</option>)}
                                                {!nodes.find(n => n.id === opt.targetNodeId) && <option value="" disabled>Destí buit</option>}
                                            </select>
                                            
                                            <details className="mb-2">
                                                <summary className="text-xs text-blue-400 cursor-pointer mb-1">Visual i Temps</summary>
                                                <div className="pl-2 border-l border-gray-600 space-y-2 mt-1">
                                                    <div className="flex gap-2"><div className="flex-1"><label className="text-[10px] text-gray-500">Inici</label><input type="number" step="0.5" value={opt.startTime} onChange={(e) => updateOption(opt.id, 'startTime', parseFloat(e.target.value))} className="w-full bg-gray-900 border border-gray-600 text-xs px-1 rounded"/></div><div className="flex-1"><label className="text-[10px] text-gray-500">Fi</label><input type="number" step="0.5" value={opt.endTime || duration} onChange={(e) => updateOption(opt.id, 'endTime', parseFloat(e.target.value))} className="w-full bg-gray-900 border border-gray-600 text-xs px-1 rounded"/></div></div>
                                                    <div className="flex gap-2 mb-2"><div className="flex-1 flex items-center gap-1 bg-gray-900 p-1.5 rounded"><input type="checkbox" checked={opt.singleUse || false} onChange={(e) => updateOption(opt.id, 'singleUse', e.target.checked)} className="w-3 h-3"/><Ghost size={12}/><label className="text-[10px] text-gray-400">Un sol ús</label></div><div className="flex-1 flex items-center gap-1 bg-gray-900 p-1.5 rounded"><input type="checkbox" checked={opt.isHotspot || false} onChange={(e) => updateOption(opt.id, 'isHotspot', e.target.checked)} className="w-3 h-3"/><EyeOff size={12}/><label className="text-[10px] text-gray-400">Hotspot</label></div></div>
                                                    {opt.isHotspot && (<div className="mb-2"><label className="text-[10px] text-gray-500">Text al passar el ratolí</label><input type="text" value={opt.hoverText || ''} onChange={(e) => updateOption(opt.id, 'hoverText', e.target.value)} className="w-full bg-gray-900 border border-gray-600 text-xs px-1 rounded"/></div>)}
                                                    <div className="bg-gray-900 p-2 rounded mb-2 border border-gray-600"><div className="flex items-center justify-between mb-1"><div className="flex items-center gap-1"><MapPin size={12} className={opt.useKeyframes ? "text-orange-400" : "text-gray-500"}/><label className="text-[10px] text-gray-400">Animació</label></div><input type="checkbox" checked={opt.useKeyframes || false} onChange={(e) => updateOption(opt.id, 'useKeyframes', e.target.checked)} className="w-3 h-3"/></div>{opt.useKeyframes && (<div className="space-y-1"><button onClick={() => addKeyframe(opt)} className="w-full text-xs bg-orange-600 hover:bg-orange-500 text-white rounded py-1 mt-1 flex items-center justify-center gap-1"><Plus size={10}/>Keyframe</button>{opt.keyframes && opt.keyframes.length > 0 && (<div className="max-h-24 overflow-y-auto mt-2 space-y-1 border-t border-gray-700 pt-1">{opt.keyframes.map((kf, ki) => (<div key={ki} className="flex justify-between items-center text-[10px] bg-gray-800 p-1 rounded"><button onClick={() => seekToKeyframe(kf.time)} className="text-blue-300 hover:underline flex items-center gap-1"><Target size={10}/> {kf.time.toFixed(1)}s</button><button onClick={() => deleteKeyframe(opt.id, kf.time)} className="text-red-400 hover:text-red-300"><Trash2 size={10}/></button></div>))}</div>)}</div>)}</div>
                                                    {!opt.isHotspot && (<div><label className="text-[10px] text-gray-500">Colors</label><div className="flex gap-2"><input type="color" value={opt.style.backgroundColor} onChange={(e) => batchUpdateOptionStyles(opt.id, {backgroundColor: e.target.value})} className="h-5 w-full"/><input type="color" value={opt.style.color} onChange={(e) => batchUpdateOptionStyles(opt.id, {color: e.target.value})} className="h-5 w-full"/></div></div>)}
                                                </div>
                                            </details>

                                            <details>
                                                <summary className="text-xs text-purple-400 cursor-pointer mb-1">Lògica (Variables)</summary>
                                                <div className="pl-2 border-l border-gray-600 space-y-2 mt-1 bg-gray-800 p-2 rounded">
                                                    <div><label className="text-[10px] text-gray-500 block mb-1">Mostrar si...</label><div className="flex gap-1"><select value={opt.condition?.variable || ''} onChange={(e) => updateOption(opt.id, 'condition', e.target.value ? { ...opt.condition, variable: e.target.value, operator: 'gt', value: 0 } : null)} className="w-1/3 bg-gray-900 text-[10px] rounded"><option value="">(Sempre)</option>{variables.map(v => <option key={v.name} value={v.name}>{v.name}</option>)}</select>{opt.condition?.variable && (<><select value={opt.condition.operator} onChange={(e) => updateOption(opt.id, 'condition', { ...opt.condition, operator: e.target.value })} className="w-1/3 bg-gray-900 text-[10px] rounded"><option value="gt">&gt;</option><option value="lt">&lt;</option><option value="eq">=</option><option value="neq">!=</option></select><input type="number" value={opt.condition.value} onChange={(e) => updateOption(opt.id, 'condition', { ...opt.condition, value: e.target.value })} className="w-1/3 bg-gray-900 text-[10px] rounded px-1"/></>)}</div></div>
                                                    <div><label className="text-[10px] text-gray-500 block mb-1">En clicar...</label><div className="flex gap-1"><select value={opt.effects?.[0]?.variable || ''} onChange={(e) => { const newEffect = e.target.value ? { variable: e.target.value, operator: 'add', value: 1 } : null; updateOption(opt.id, 'effects', newEffect ? [newEffect] : []); }} className="w-1/3 bg-gray-900 text-[10px] rounded"><option value="">(Res)</option>{variables.map(v => <option key={v.name} value={v.name}>{v.name}</option>)}</select>{opt.effects?.[0]?.variable && (<><select value={opt.effects[0].operator} onChange={(e) => updateOption(opt.id, 'effects', [{ ...opt.effects[0], operator: e.target.value }])} className="w-1/3 bg-gray-900 text-[10px] rounded"><option value="set">Set</option><option value="add">Add</option><option value="sub">Sub</option></select><input type="number" value={opt.effects[0].value} onChange={(e) => updateOption(opt.id, 'effects', [{ ...opt.effects[0], value: e.target.value }])} className="w-1/3 bg-gray-900 text-[10px] rounded px-1"/></>)}</div></div>
                                                </div>
                                            </details>
                                        </div>
                                    ))}
                                </div>
                              </>
                          )}
                        </div>
                      </aside>
                    )}
                  </>
                )}
              </div>

              {/* MODALS */}
              {showVariablesModal && (
                  <div className="fixed inset-0 z-50 bg-black/80 flex items-center justify-center p-4">
                      <div className="bg-gray-800 rounded-lg shadow-xl w-full max-w-md p-6"><h3 className="text-xl font-bold mb-4 flex items-center gap-2"><Database size={20}/> Gestor de Variables</h3><div className="space-y-2 mb-4 max-h-60 overflow-y-auto">{variables.map((v, i) => (<div key={i} className="flex gap-2 items-center"><input type="text" value={v.name} onChange={(e) => updateVariable(i, 'name', e.target.value)} className="bg-gray-900 border border-gray-600 rounded px-2 py-1 text-sm flex-1"/><span className="text-gray-500">=</span><input type="number" value={v.value} onChange={(e) => updateVariable(i, 'value', parseFloat(e.target.value))} className="bg-gray-900 border border-gray-600 rounded px-2 py-1 text-sm w-20"/><button onClick={() => removeVariable(i)} className="text-red-400 hover:bg-red-900/20 p-1 rounded"><Trash2 size={14}/></button></div>))}</div><div className="flex justify-between"><button onClick={addVariable} className="text-blue-400 text-sm hover:underline">+ Afegir Variable</button><button onClick={() => setShowVariablesModal(false)} className="bg-blue-600 px-4 py-2 rounded text-sm font-bold">Tancar</button></div></div></div>
              )}
              {showMissingFilesModal && (<div className="fixed inset-0 z-50 bg-black/80 flex items-center justify-center p-4"><div className="bg-gray-800 border border-gray-600 rounded-lg shadow-2xl max-w-md w-full p-6 text-center"><div className="w-16 h-16 bg-yellow-500/20 rounded-full flex items-center justify-center mx-auto mb-4"><AlertTriangle size={32} className="text-yellow-500" /></div><h3 className="text-xl font-bold text-white mb-2">Vídeos No Trobats</h3><p className="text-gray-300 text-sm mb-6">Selecciona la carpeta <strong>local</strong> on tens guardats els vídeos.</p><div className="flex gap-3 justify-center"><button onClick={() => setShowMissingFilesModal(false)} className="px-4 py-2 rounded bg-gray-700 hover:bg-gray-600 text-gray-300 text-sm">Ignorar</button><button onClick={() => bulkVideoInputRef.current?.click()} className="px-4 py-2 rounded bg-blue-600 hover:bg-blue-500 text-white text-sm font-bold flex items-center gap-2"><FolderOpen size={16} /> Seleccionar Carpeta</button></div></div></div>)}
              {showLoadModal && (<div className="fixed inset-0 z-50 bg-black/90 flex items-center justify-center p-4"><div className="bg-gray-800 border border-gray-600 rounded-lg shadow-2xl max-w-lg w-full p-8"><h3 className="text-2xl font-bold text-white mb-6 flex items-center gap-2"><FolderOpen className="text-blue-500" /> Carregar Projecte</h3><div className="space-y-6"><div className={`p-4 rounded border transition-colors ${videosLoadedCount > 0 ? 'bg-green-900/30 border-green-500/50' : 'bg-gray-750 border-gray-600'}`}><div className="flex justify-between items-center mb-2"><span className="font-semibold text-gray-200">Pas 1: Localitzar Vídeos</span>{videosLoadedCount > 0 && <CheckCircle size={16} className="text-green-500" />}</div><p className="text-xs text-gray-400 mb-3">Selecciona la carpeta amb els fitxers .mp4.</p><button onClick={() => bulkVideoInputRef.current?.click()} className="w-full py-2 bg-gray-700 hover:bg-gray-600 text-white rounded text-sm flex items-center justify-center gap-2 border border-gray-500"><FileVideo size={16} />{videosLoadedCount > 0 ? `${videosLoadedCount} vídeos detectats` : 'Seleccionar Carpeta'}</button></div><div className={`p-4 rounded border transition-colors ${videosLoadedCount === 0 ? 'opacity-50 pointer-events-none bg-gray-800 border-gray-700' : 'bg-gray-750 border-gray-600'}`}><div className="flex justify-between items-center mb-2"><span className="font-semibold text-gray-200">Pas 2: Carregar Estructura</span></div><p className="text-xs text-gray-400 mb-3">Selecciona el fitxer .json del projecte.</p><button onClick={() => projectInputRef.current?.click()} disabled={videosLoadedCount === 0} className="w-full py-2 bg-blue-600 hover:bg-blue-500 text-white rounded text-sm flex items-center justify-center gap-2 font-bold disabled:bg-gray-600"><FileUp size={16} /> Seleccionar JSON</button></div></div><div className="mt-8 flex justify-end"><button onClick={() => setShowLoadModal(false)} className="text-gray-400 hover:text-white text-sm underline">Cancel·lar</button></div></div></div>)}
              {showDeleteModal && (<div className="fixed inset-0 z-50 bg-black/80 flex items-center justify-center p-4"><div className="bg-gray-800 border border-gray-600 rounded-lg shadow-2xl max-w-sm w-full p-6 text-center"><div className="w-12 h-12 bg-red-500/20 rounded-full flex items-center justify-center mx-auto mb-4"><Trash2 size={24} className="text-red-500" /></div><h3 className="text-lg font-bold text-white mb-2">Esborrar Escena?</h3><div className="flex gap-3 justify-center"><button onClick={() => { setShowDeleteModal(false); setNodeToDelete(null); }} className="flex-1 py-2 rounded bg-gray-700 hover:bg-gray-600 text-gray-300 text-sm">Cancel·lar</button><button onClick={confirmDeleteNode} className="flex-1 py-2 rounded bg-red-600 hover:bg-red-500 text-white text-sm font-bold">Esborrar</button></div></div></div>)}
            </div>
          );
        }
        
        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
