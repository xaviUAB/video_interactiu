import React, { useState, useRef, useEffect, useCallback } from 'react';
import { 
  Play, Pause, Plus, Trash2, Save, Layout, 
  Type, Clock, Palette, MonitorPlay, Settings,
  ChevronRight, ArrowRightCircle, Image as ImageIcon,
  Network, Upload, FileVideo, Move, X, Maximize,
  GripHorizontal, Scaling, MousePointer2,
  Download, FolderOpen, Flag, PlayCircle,
  Copy, Clipboard, AlertCircle
} from 'lucide-react';

// --- Utilitats ---
const hexToRgba = (hex, alpha = 1) => {
  let r = 0, g = 0, b = 0;
  if (!hex) return `rgba(0,0,0,${alpha})`;
  if (hex.length === 4) {
    r = parseInt(hex[1] + hex[1], 16);
    g = parseInt(hex[2] + hex[2], 16);
    b = parseInt(hex[3] + hex[3], 16);
  } else if (hex.length === 7) {
    r = parseInt(hex[1] + hex[2], 16);
    g = parseInt(hex[3] + hex[4], 16);
    b = parseInt(hex[5] + hex[6], 16);
  }
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
};

// --- Dades d'exemple ---
const INITIAL_NODES = [
  {
    id: 'intro',
    title: 'Introducció',
    videoUrl: 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4',
    position: { x: 100, y: 100 },
    color: '#3b82f6',
    options: [
      {
        id: 'opt1',
        label: 'Anar al Bosc',
        targetNodeId: 'bosc',
        startTime: 5,
        endTime: 15,
        style: { 
          top: 70, left: 20, 
          width: 160, height: 50, 
          fontSize: 16, color: '#ffffff', backgroundColor: '#3b82f6', bgOpacity: 1,
          padding: 10, borderRadius: 8, fontFamily: 'sans-serif' 
        }
      },
      {
        id: 'opt2',
        label: 'Quedar-se a casa',
        targetNodeId: 'casa',
        startTime: 5,
        endTime: 15,
        style: { 
          top: 70, left: 60, 
          width: 180, height: 50,
          fontSize: 16, color: '#ffffff', backgroundColor: '#ef4444', bgOpacity: 0.8,
          padding: 10, borderRadius: 8, fontFamily: 'serif' 
        }
      }
    ]
  },
  {
    id: 'bosc',
    title: 'Escena del Bosc',
    videoUrl: 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ElephantsDream.mp4',
    position: { x: 500, y: 50 },
    color: '#10b981',
    options: [
      {
        id: 'opt3',
        label: 'Tornar al inici',
        targetNodeId: 'intro',
        startTime: 10,
        endTime: 60,
        style: { 
          top: 80, left: 40, 
          width: 200, height: 60,
          fontSize: 18, color: '#000000', backgroundColor: '#fbbf24', bgOpacity: 1,
          padding: 12, borderRadius: 50, fontFamily: 'monospace' 
        }
      }
    ]
  },
  {
    id: 'casa',
    title: 'Escena de Casa',
    videoUrl: 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ForBiggerBlazes.mp4',
    position: { x: 500, y: 400 },
    color: '#ef4444',
    options: [
      {
        id: 'opt4',
        label: 'Reiniciar',
        targetNodeId: 'intro',
        startTime: 3,
        endTime: 13,
        style: { 
          top: 50, left: 45, 
          width: 150, height: 60,
          fontSize: 20, color: '#ffffff', backgroundColor: '#10b981', bgOpacity: 0.9,
          padding: 15, borderRadius: 4, fontFamily: 'sans-serif' 
        }
      }
    ]
  }
];

// --- Component de Gràfic (NodeGraph) ---
const NodeGraph = ({ 
  nodes, 
  onUpdateNode, 
  onSelectNode, 
  onDeleteNode, 
  startNodeId, 
  onSetStartNode,
  onPreviewNode 
}) => {
  const [draggingNodeId, setDraggingNodeId] = useState(null);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const containerRef = useRef(null);

  const handleMouseDown = (e, nodeId) => {
    e.stopPropagation(); 
    const node = nodes.find(n => n.id === nodeId);
    if (!node) return;
    const containerRect = containerRef.current.getBoundingClientRect();
    const scrollLeft = containerRef.current.scrollLeft;
    const scrollTop = containerRef.current.scrollTop;
    const mouseX = e.clientX - containerRect.left + scrollLeft;
    const mouseY = e.clientY - containerRect.top + scrollTop;
    setDragOffset({ x: mouseX - (node.position?.x || 0), y: mouseY - (node.position?.y || 0) });
    setDraggingNodeId(nodeId);
  };

  const handleMouseMove = useCallback((e) => {
    if (!draggingNodeId) return;
    const containerRect = containerRef.current.getBoundingClientRect();
    const scrollLeft = containerRef.current.scrollLeft;
    const scrollTop = containerRef.current.scrollTop;
    const mouseX = e.clientX - containerRect.left + scrollLeft;
    const mouseY = e.clientY - containerRect.top + scrollTop;
    const newX = mouseX - dragOffset.x;
    const newY = mouseY - dragOffset.y;
    const updatedNode = nodes.find(n => n.id === draggingNodeId);
    if (updatedNode) {
      onUpdateNode(draggingNodeId, 'position', { x: newX, y: newY });
    }
  }, [draggingNodeId, dragOffset, nodes, onUpdateNode]);

  const handleMouseUp = () => setDraggingNodeId(null);

  useEffect(() => {
    if (draggingNodeId) {
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleMouseUp);
    } else {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    }
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    };
  }, [draggingNodeId, handleMouseMove]);

  const addOptionToNode = (nodeId) => {
    const node = nodes.find(n => n.id === nodeId);
    const newOption = {
      id: `opt-${Date.now()}`,
      label: 'Nova Opció',
      targetNodeId: nodes[0].id, 
      startTime: 0,
      endTime: 10,
      style: { top: 50, left: 50, width: 120, height: 40, fontSize: 14, color: '#fff', backgroundColor: '#333', bgOpacity: 1, padding: 8, borderRadius: 4, fontFamily: 'sans-serif' }
    };
    onUpdateNode(nodeId, 'options', [...node.options, newOption]);
  };

  const updateNodeOption = (nodeId, optionId, field, value) => {
    const node = nodes.find(n => n.id === nodeId);
    const updatedOptions = node.options.map(opt => opt.id === optionId ? { ...opt, [field]: value } : opt);
    onUpdateNode(nodeId, 'options', updatedOptions);
  };
  
  const deleteNodeOption = (nodeId, optionId) => {
    const node = nodes.find(n => n.id === nodeId);
    const updatedOptions = node.options.filter(opt => opt.id !== optionId);
    onUpdateNode(nodeId, 'options', updatedOptions);
  };

  return (
    <div ref={containerRef} className="flex-1 bg-gray-950 overflow-auto relative min-h-full cursor-crosshair" style={{ backgroundImage: 'radial-gradient(#374151 1px, transparent 1px)', backgroundSize: '20px 20px' }}>
      <div className="relative" style={{ minWidth: '3000px', minHeight: '3000px' }}>
        <svg className="absolute inset-0 w-full h-full pointer-events-none z-0">
          <defs><marker id="arrowhead" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto"><path d="M2,2 L10,6 L2,10 L2,2" fill="#6b7280" /></marker></defs>
          {nodes.map(node => node.options.map((opt, idx) => {
              const targetNode = nodes.find(n => n.id === opt.targetNodeId);
              if (!targetNode) return null;
              const startX = (node.position?.x || 0) + 280;
              const startY = (node.position?.y || 0) + 110 + (idx * 36);
              const endX = targetNode.position?.x || 0;
              const endY = (targetNode.position?.y || 0) + 30;
              const cp1X = startX + (endX - startX) / 2;
              return <path key={opt.id} d={`M ${startX} ${startY} C ${cp1X} ${startY}, ${cp1X} ${endY}, ${endX} ${endY}`} stroke={node.color || '#4b5563'} strokeWidth="3" fill="none" markerEnd="url(#arrowhead)" className="opacity-60" />;
          }))}
        </svg>
        {nodes.map(node => (
          <div key={node.id} className="absolute w-[280px] bg-gray-800 rounded-lg shadow-2xl border border-gray-700 flex flex-col z-10 group" style={{ left: node.position?.x || 0, top: node.position?.y || 0 }}>
            {/* NODE HEADER */}
            <div className="h-10 rounded-t-lg flex items-center justify-between px-3 cursor-move select-none" style={{ backgroundColor: node.color || '#374151' }} onMouseDown={(e) => handleMouseDown(e, node.id)}>
              <div className="flex items-center gap-2 text-white font-bold text-sm truncate max-w-[140px]"><Move size={14} className="opacity-50" /><span className="truncate">{node.title}</span></div>
              <div className="flex items-center gap-1">
                {/* PLAY FROM HERE */}
                <button 
                  onClick={(e) => { e.stopPropagation(); onPreviewNode(node.id); }}
                  className="text-white/80 hover:text-green-300 p-1 hover:bg-black/20 rounded"
                  title="Previsualitzar des d'aquest node"
                >
                  <PlayCircle size={14} />
                </button>
                {/* SET START NODE */}
                <button 
                  onClick={(e) => { e.stopPropagation(); onSetStartNode(node.id); }}
                  className={`p-1 rounded hover:bg-black/20 ${startNodeId === node.id ? 'text-green-400' : 'text-white/40 hover:text-white'}`}
                  title="Marcar com a node d'inici"
                >
                  <Flag size={14} fill={startNodeId === node.id ? "currentColor" : "none"}/>
                </button>

                <div className="w-px h-4 bg-white/20 mx-1"></div>

                <input type="color" value={node.color || '#374151'} onChange={(e) => onUpdateNode(node.id, 'color', e.target.value)} className="w-5 h-5 rounded cursor-pointer border-none bg-transparent" />
                <button onClick={() => onDeleteNode(node.id)} className="text-white/60 hover:text-white hover:bg-black/20 rounded p-1"><X size={14} /></button>
              </div>
            </div>

            {/* NODE BODY */}
            <div className="p-3 space-y-3 bg-gray-800 rounded-b-lg">
              <input type="text" value={node.title} onChange={(e) => onUpdateNode(node.id, 'title', e.target.value)} className="w-full bg-gray-900 border border-gray-700 rounded px-2 py-1 text-xs text-gray-200 outline-none" placeholder="Títol..." />
              <div className="space-y-1">
                <div className="flex justify-between items-center text-[10px] text-gray-500 uppercase tracking-wider font-semibold"><span>Opcions ({node.options.length})</span><button onClick={() => addOptionToNode(node.id)} className="hover:text-blue-400"><Plus size={12} /></button></div>
                {node.options.map((opt) => (
                  <div key={opt.id} className="flex items-center gap-1 bg-gray-900 p-1.5 rounded border border-gray-700 relative">
                    <input type="text" value={opt.label} onChange={(e) => updateNodeOption(node.id, opt.id, 'label', e.target.value)} className="w-24 bg-transparent border-none text-xs text-white p-0 truncate font-medium" />
                    <ArrowRightCircle size={12} className="text-gray-500 shrink-0" />
                    <select value={opt.targetNodeId} onChange={(e) => updateNodeOption(node.id, opt.id, 'targetNodeId', e.target.value)} className="flex-1 bg-gray-800 text-[10px] text-gray-300 border-none rounded py-0.5 px-1 h-5 cursor-pointer">{nodes.map(n => <option key={n.id} value={n.id}>{n.title}</option>)}</select>
                    <button onClick={() => deleteNodeOption(node.id, opt.id)} className="text-gray-600 hover:text-red-400"><Trash2 size={12} /></button>
                  </div>
                ))}
              </div>
              <button onClick={() => { onSelectNode(node.id); }} className="w-full mt-2 py-1 bg-gray-700 hover:bg-gray-600 text-xs text-gray-300 rounded flex items-center justify-center gap-2"><Settings size={12} /> Editar</button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

export default function App() {
  const [nodes, setNodes] = useState(INITIAL_NODES);
  const [selectedNodeId, setSelectedNodeId] = useState('intro');
  const [startNodeId, setStartNodeId] = useState('intro'); 
  const [mode, setMode] = useState('edit'); 
  const [currentNodeId, setCurrentNodeId] = useState('intro'); 
  
  // Video State
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [videoError, setVideoError] = useState(null); // Error state for video
  
  // Dragging State
  const [dragState, setDragState] = useState({ isDragging: false, type: null, targetId: null, startX: 0, startY: 0, initialVal: {} });
  
  // Clipboard Style State
  const [clipboardStyle, setClipboardStyle] = useState(null);

  const videoRef = useRef(null);
  const videoContainerRef = useRef(null);
  const timelineTrackRef = useRef(null); 
  const fileInputRef = useRef(null);
  const projectInputRef = useRef(null); 

  const activeNodeId = mode === 'preview' ? currentNodeId : selectedNodeId;
  const activeNode = nodes.find(n => n.id === activeNodeId) || nodes[0];

  // Reset error when switching nodes
  useEffect(() => {
    setVideoError(null);
  }, [activeNodeId]);

  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;
    
    const handleTimeUpdate = () => setCurrentTime(video.currentTime);
    const handleLoadedMetadata = () => {
      setDuration(video.duration);
      setVideoError(null); // Clear errors on success
    };
    const handleError = (e) => {
        console.error("Video Error:", e);
        setVideoError("No s'ha pogut carregar el vídeo.");
        setIsPlaying(false);
    };

    video.addEventListener('timeupdate', handleTimeUpdate);
    video.addEventListener('loadedmetadata', handleLoadedMetadata);
    video.addEventListener('error', handleError);
    
    return () => {
      video.removeEventListener('timeupdate', handleTimeUpdate);
      video.removeEventListener('loadedmetadata', handleLoadedMetadata);
      video.removeEventListener('error', handleError);
    };
  }, [activeNodeId, mode]);

  useEffect(() => {
    if (videoRef.current) {
      videoRef.current.load();
      if (mode === 'preview') {
        videoRef.current.play().catch(e => console.log("Auto-play blocked", e));
        setIsPlaying(true);
      } else {
        setIsPlaying(false);
      }
    }
    setCurrentTime(0);
  }, [activeNodeId, mode]);

  const togglePlay = () => {
    if (videoRef.current) {
      if (isPlaying) {
        videoRef.current.pause();
        setIsPlaying(false);
      } else {
        const playPromise = videoRef.current.play();
        if (playPromise !== undefined) {
            playPromise
                .then(() => setIsPlaying(true))
                .catch(error => {
                    console.log("Play interrupted or failed:", error);
                    setIsPlaying(false);
                });
        }
      }
    }
  };

  // --- SAVE & LOAD PROJECT ---
  const handleSaveProject = () => {
    const projectData = {
      version: '1.0',
      timestamp: Date.now(),
      startNodeId: startNodeId,
      nodes: nodes
    };
    const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `intervideo-project-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  };

  const handleLoadProject = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const data = JSON.parse(event.target.result);
        if (data.nodes && Array.isArray(data.nodes)) {
          setNodes(data.nodes);
          if (data.startNodeId) setStartNodeId(data.startNodeId);
          setSelectedNodeId(data.startNodeId || data.nodes[0].id);
          alert("Projecte carregat correctament!");
        } else {
          alert("Format de fitxer invàlid.");
        }
      } catch (err) {
        console.error(err);
        alert("Error en llegir el fitxer JSON.");
      }
    };
    reader.readAsText(file);
    e.target.value = ''; // Reset input
  };

  // --- STYLE COPY / PASTE ---
  const handleCopyStyle = (sourceStyle) => {
    setClipboardStyle({
        backgroundColor: sourceStyle.backgroundColor,
        color: sourceStyle.color,
        bgOpacity: sourceStyle.bgOpacity !== undefined ? sourceStyle.bgOpacity : 1,
        fontSize: sourceStyle.fontSize,
        fontFamily: sourceStyle.fontFamily,
        borderRadius: sourceStyle.borderRadius,
        padding: sourceStyle.padding
    });
  };

  const handlePasteStyle = (targetOptionId) => {
    if (!clipboardStyle) return;
    batchUpdateOptionStyles(targetOptionId, clipboardStyle);
  };

  // --- CRUD Nodes ---
  const addNode = () => {
    const newId = `escena-${Date.now()}`;
    setNodes([...nodes, { id: newId, title: 'Nova Escena', videoUrl: '', position: { x: 300, y: 300 }, color: '#6b7280', options: [] }]);
    setSelectedNodeId(newId);
  };
  const updateNode = (id, field, value) => setNodes(nodes.map(n => n.id === id ? { ...n, [field]: value } : n));
  const deleteNode = (id) => {
    if (nodes.length <= 1) return alert("Mínim una escena.");
    if (!window.confirm("Esborrar?")) return;
    const newNodes = nodes.filter(n => n.id !== id);
    setNodes(newNodes);
    if (selectedNodeId === id) setSelectedNodeId(newNodes[0].id);
    if (startNodeId === id) setStartNodeId(newNodes[0].id); 
  };

  const handleFileUpload = (e) => {
    const file = e.target.files[0];
    if (file) updateNode(activeNode.id, 'videoUrl', URL.createObjectURL(file));
  };

  // --- CRUD Options ---
  const addOption = () => {
    const newOption = {
      id: `opt-${Date.now()}`,
      label: 'Opció Nova',
      targetNodeId: nodes[0].id,
      startTime: Math.floor(currentTime),
      endTime: duration || Math.floor(currentTime) + 10,
      style: { top: 50, left: 50, width: 150, height: 50, fontSize: 14, color: '#ffffff', backgroundColor: activeNode.color || '#6366f1', bgOpacity: 1, padding: 10, borderRadius: 6, fontFamily: 'sans-serif' }
    };
    updateNode(activeNodeId, 'options', [...activeNode.options, newOption]);
  };
  
  const updateOption = (optionId, field, value) => {
    const updatedOptions = activeNode.options.map(opt => opt.id === optionId ? { ...opt, [field]: value } : opt);
    updateNode(activeNodeId, 'options', updatedOptions);
  };

  const batchUpdateOptionStyles = (optionId, newStyles) => {
    const updatedOptions = activeNode.options.map(opt => 
      opt.id === optionId ? { ...opt, style: { ...opt.style, ...newStyles } } : opt
    );
    updateNode(activeNodeId, 'options', updatedOptions);
  };

  const batchUpdateOptionFields = (optionId, newFields) => {
    const updatedOptions = activeNode.options.map(opt => 
      opt.id === optionId ? { ...opt, ...newFields } : opt
    );
    updateNode(activeNodeId, 'options', updatedOptions);
  };

  const updateOptionStyle = (optionId, styleField, value) => {
    const updatedOptions = activeNode.options.map(opt => opt.id === optionId ? { ...opt, style: { ...opt.style, [styleField]: value } } : opt);
    updateNode(activeNodeId, 'options', updatedOptions);
  };

  const removeOption = (optionId) => {
    updateNode(activeNodeId, 'options', activeNode.options.filter(opt => opt.id !== optionId));
  };

  // --- DRAG & DROP & RESIZE HANDLERS ---

  const handleButtonMouseDown = (e, opt) => {
    if (mode !== 'edit') return;
    e.stopPropagation(); e.preventDefault();
    setDragState({
      isDragging: true, type: 'move', targetId: opt.id,
      startX: e.clientX, startY: e.clientY,
      initialVal: { left: parseFloat(opt.style.left) || 0, top: parseFloat(opt.style.top) || 0 }
    });
  };

  const handleResizeMouseDown = (e, opt) => {
    if (mode !== 'edit') return;
    e.stopPropagation(); e.preventDefault();
    setDragState({
      isDragging: true, type: 'resize', targetId: opt.id,
      startX: e.clientX, startY: e.clientY,
      initialVal: { width: parseFloat(opt.style.width) || 100, height: parseFloat(opt.style.height) || 50 }
    });
  };

  const handleTimelineItemMouseDown = (e, opt, type) => {
    if (mode !== 'edit') return;
    e.stopPropagation(); e.preventDefault();
    setDragState({
      isDragging: true, type: type, targetId: opt.id,
      startX: e.clientX,
      initialVal: { startTime: opt.startTime, endTime: opt.endTime || duration }
    });
  };

  const handleGlobalMouseMove = useCallback((e) => {
    if (!dragState.isDragging) return;

    // 1. MOVE BUTTON ON VIDEO STAGE
    if (dragState.type === 'move') {
      const container = videoContainerRef.current;
      if (!container) return;
      const rect = container.getBoundingClientRect();
      const deltaX = e.clientX - dragState.startX;
      const deltaY = e.clientY - dragState.startY;
      
      const deltaLeftPercent = (deltaX / rect.width) * 100;
      const deltaTopPercent = (deltaY / rect.height) * 100;

      const newLeft = Math.max(0, Math.min(100, dragState.initialVal.left + deltaLeftPercent));
      const newTop = Math.max(0, Math.min(100, dragState.initialVal.top + deltaTopPercent));
      
      batchUpdateOptionStyles(dragState.targetId, { left: newLeft, top: newTop });
    }

    // 2. RESIZE BUTTON
    if (dragState.type === 'resize') {
      const deltaX = e.clientX - dragState.startX;
      const deltaY = e.clientY - dragState.startY;
      const newW = Math.max(20, dragState.initialVal.width + deltaX);
      const newH = Math.max(20, dragState.initialVal.height + deltaY);
      
      batchUpdateOptionStyles(dragState.targetId, { width: newW, height: newH });
    }

    // 3. TIMELINE INTERACTIONS
    if (['timeline-move', 'timeline-start', 'timeline-end'].includes(dragState.type)) {
      const trackContainer = timelineTrackRef.current;
      if (!trackContainer || duration === 0) return;
      const rect = trackContainer.getBoundingClientRect();
      const deltaX = e.clientX - dragState.startX;
      
      const deltaSeconds = (deltaX / rect.width) * duration;

      const opt = activeNode.options.find(o => o.id === dragState.targetId);
      if (!opt) return;

      if (dragState.type === 'timeline-move') {
        const durationSpan = dragState.initialVal.endTime - dragState.initialVal.startTime;
        let newStart = Math.max(0, dragState.initialVal.startTime + deltaSeconds);
        let newEnd = newStart + durationSpan;
        
        if (newEnd > duration) {
            newEnd = duration;
            newStart = duration - durationSpan;
        }
        batchUpdateOptionFields(opt.id, { startTime: newStart, endTime: newEnd });
      } 
      else if (dragState.type === 'timeline-start') {
        let newStart = Math.max(0, dragState.initialVal.startTime + deltaSeconds);
        if (newStart >= dragState.initialVal.endTime - 0.5) newStart = dragState.initialVal.endTime - 0.5;
        batchUpdateOptionFields(opt.id, { startTime: newStart });
      }
      else if (dragState.type === 'timeline-end') {
        let newEnd = Math.min(duration, dragState.initialVal.endTime + deltaSeconds);
        if (newEnd <= dragState.initialVal.startTime + 0.5) newEnd = dragState.initialVal.startTime + 0.5;
        batchUpdateOptionFields(opt.id, { endTime: newEnd });
      }
    }

  }, [dragState, activeNode, duration]);

  const handleGlobalMouseUp = useCallback(() => {
    setDragState({ isDragging: false, type: null, targetId: null });
  }, []);

  useEffect(() => {
    if (dragState.isDragging) {
      window.addEventListener('mousemove', handleGlobalMouseMove);
      window.addEventListener('mouseup', handleGlobalMouseUp);
    }
    return () => {
      window.removeEventListener('mousemove', handleGlobalMouseMove);
      window.removeEventListener('mouseup', handleGlobalMouseUp);
    };
  }, [dragState, handleGlobalMouseMove, handleGlobalMouseUp]);

  const handleTimelineClick = (e) => {
    if (dragState.isDragging) return; 
    const rect = timelineTrackRef.current.getBoundingClientRect();
    const clickX = e.clientX - rect.left; 
    const newTime = (clickX / rect.width) * duration;
    if (isFinite(newTime)) {
        setCurrentTime(newTime);
        if (videoRef.current) videoRef.current.currentTime = newTime;
    }
  };

  return (
    <div className="flex flex-col h-screen bg-gray-900 text-gray-100 font-sans overflow-hidden">
      
      {/* Header */}
      <header className="h-14 bg-gray-800 border-b border-gray-700 flex items-center justify-between px-4 shrink-0 z-20">
        <div className="flex items-center gap-2">
          <MonitorPlay className="text-blue-500 w-6 h-6" />
          <h1 className="font-bold text-lg">InterVideo Studio</h1>
        </div>
        
        <div className="flex items-center gap-3">
            {/* SAVE/LOAD */}
            <div className="flex bg-gray-900 rounded-lg p-1 border border-gray-700 mr-2">
                <button 
                    onClick={handleSaveProject} 
                    className="p-1.5 text-gray-400 hover:text-white hover:bg-gray-700 rounded transition-colors"
                    title="Desar Projecte (JSON)"
                >
                    <Download size={16} />
                </button>
                <button 
                    onClick={() => projectInputRef.current?.click()} 
                    className="p-1.5 text-gray-400 hover:text-white hover:bg-gray-700 rounded transition-colors"
                    title="Carregar Projecte (JSON)"
                >
                    <FolderOpen size={16} />
                </button>
                <input type="file" ref={projectInputRef} onChange={handleLoadProject} accept=".json" className="hidden" />
            </div>

            {/* VIEW MODES */}
            <div className="flex bg-gray-900 rounded-lg p-1 border border-gray-700">
            <button onClick={() => { setMode('edit'); setIsPlaying(false); }} className={`px-4 py-1.5 rounded-md text-sm font-medium ${mode === 'edit' ? 'bg-blue-600 text-white' : 'text-gray-400'}`}>Editor</button>
            <button onClick={() => setMode('graph')} className={`px-4 py-1.5 rounded-md text-sm font-medium ${mode === 'graph' ? 'bg-purple-600 text-white' : 'text-gray-400'}`}>Mapa</button>
            <button 
                onClick={() => { setMode('preview'); setCurrentNodeId(startNodeId); }} // DEFAULT TO START NODE
                className={`px-4 py-1.5 rounded-md text-sm font-medium ${mode === 'preview' ? 'bg-green-600 text-white' : 'text-gray-400'}`}
                title="Previsualitzar des de l'inici"
            >
                Previsualitzar
            </button>
            </div>
        </div>
      </header>

      <div className="flex flex-1 overflow-hidden relative">
        {mode === 'graph' ? (
           <div className="flex-1 flex flex-col relative">
             <div className="absolute top-4 left-4 z-20"><button onClick={addNode} className="bg-blue-600 text-white px-4 py-2 rounded flex items-center gap-2"><Plus size={16} /> Nova Escena</button></div>
             <NodeGraph 
                nodes={nodes} 
                onUpdateNode={updateNode} 
                onSelectNode={(id) => { setSelectedNodeId(id); setMode('edit'); }} 
                onDeleteNode={deleteNode} 
                startNodeId={startNodeId}
                onSetStartNode={setStartNodeId}
                onPreviewNode={(id) => { setCurrentNodeId(id); setMode('preview'); }}
            />
           </div>
        ) : (
          <>
            {mode === 'edit' && (
              <aside className="w-56 bg-gray-800 border-r border-gray-700 flex flex-col shrink-0">
                <div className="p-4 border-b border-gray-700 flex justify-between items-center"><h2 className="font-semibold text-gray-300">Escenes</h2><button onClick={addNode} className="text-blue-400"><Plus size={20} /></button></div>
                <div className="flex-1 overflow-y-auto p-2 space-y-2">
                  {nodes.map(node => (
                    <div key={node.id} onClick={() => setSelectedNodeId(node.id)} className={`p-3 rounded-lg cursor-pointer border-l-4 ${selectedNodeId === node.id ? 'bg-gray-750' : 'bg-gray-800 border-transparent'}`} style={{ borderLeftColor: node.color }}>
                      <h3 className="font-medium text-sm text-gray-200">{node.title}</h3>
                      {startNodeId === node.id && <span className="text-[10px] text-green-500 font-mono">★ INICI</span>}
                    </div>
                  ))}
                </div>
              </aside>
            )}

            <main className="flex-1 flex flex-col bg-gray-950 relative min-w-0">
              <div ref={videoContainerRef} className={`relative flex-1 bg-black flex items-center justify-center overflow-hidden ${mode === 'edit' ? 'select-none' : ''}`}>
                {activeNode.videoUrl ? (
                  <video 
                    ref={videoRef} 
                    className="w-full h-full object-contain" 
                    src={activeNode.videoUrl} 
                    onClick={mode === 'preview' ? togglePlay : null} 
                    loop={mode === 'edit'} 
                    playsInline 
                    crossOrigin="anonymous"
                  />
                ) : (
                  <div className="text-center text-gray-500"><ImageIcon className="w-16 h-16 mx-auto mb-4 opacity-50" /><button onClick={() => fileInputRef.current?.click()} className="text-blue-400 underline">Carregar Vídeo</button></div>
                )}

                {/* ERROR OVERLAY */}
                {videoError && (
                    <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/80 text-red-400 z-50">
                        <AlertCircle size={48} className="mb-2"/>
                        <p>{videoError}</p>
                    </div>
                )}

                <div className="absolute inset-0 pointer-events-none">
                  {activeNode.options.map(opt => {
                    const isVisible = currentTime >= opt.startTime && currentTime <= (opt.endTime || duration);
                    const shouldShow = mode === 'edit' ? true : isVisible;
                    const opacity = (mode === 'edit' && !isVisible) ? 0.3 : 1;
                    if (!shouldShow) return null;
                    const isSelected = dragState.targetId === opt.id;
                    const finalBgColor = hexToRgba(opt.style.backgroundColor, opt.style.bgOpacity !== undefined ? opt.style.bgOpacity : 1);

                    return (
                      <div
                        key={opt.id}
                        className="absolute pointer-events-auto group"
                        style={{
                          top: `${opt.style.top}%`,
                          left: `${opt.style.left}%`,
                          width: opt.style.width,
                          height: opt.style.height,
                          transform: 'translate(-50%, -50%)', 
                          opacity: opacity,
                        }}
                      >
                         <button
                            onMouseDown={(e) => handleButtonMouseDown(e, opt)}
                            onClick={() => mode === 'preview' && setCurrentNodeId(opt.targetNodeId)}
                            className={`w-full h-full flex items-center justify-center text-center overflow-hidden shadow-lg transition-transform
                                ${mode === 'edit' ? 'cursor-move hover:ring-1 hover:ring-white border border-dashed border-white/50' : 'hover:scale-105'}
                                ${isSelected ? 'ring-2 ring-yellow-400 z-50' : ''}
                            `}
                            style={{
                              fontSize: `${opt.style.fontSize}px`,
                              color: opt.style.color,
                              backgroundColor: finalBgColor,
                              padding: `${opt.style.padding}px`,
                              borderRadius: opt.style.borderRadius,
                              fontFamily: opt.style.fontFamily,
                            }}
                          >
                            {opt.label}
                          </button>
                          
                          {mode === 'edit' && (
                             <div 
                               onMouseDown={(e) => handleResizeMouseDown(e, opt)}
                               className="absolute bottom-0 right-0 w-4 h-4 bg-blue-500 cursor-nwse-resize z-50 opacity-0 group-hover:opacity-100 transition-opacity rounded-tl"
                             />
                          )}
                          
                          {mode === 'edit' && <span className="absolute -top-6 left-0 bg-black/70 text-[10px] text-white px-1 rounded whitespace-nowrap">{opt.startTime.toFixed(1)}s - {(opt.endTime || duration).toFixed(1)}s</span>}
                      </div>
                    );
                  })}
                </div>
              </div>

              {mode === 'edit' && (
                <div className="h-48 bg-gray-900 border-t border-gray-700 flex flex-col shrink-0 select-none">
                   
                   <div className="h-10 bg-gray-800 border-b border-gray-700 flex items-center px-4 gap-4 justify-between">
                      <div className="flex items-center gap-4">
                        <button onClick={togglePlay} className="text-white hover:text-blue-400">{isPlaying ? <Pause size={16}/> : <Play size={16}/>}</button>
                        <span className="text-xs font-mono text-gray-300 w-24">{currentTime.toFixed(2)}s / {duration.toFixed(2)}s</span>
                      </div>
                      <div className="text-[10px] text-gray-500">Arrossega per moure • Estira vores per durada</div>
                   </div>

                   <div className="flex-1 flex flex-col min-h-0 bg-gray-900 relative">
                      
                      {/* Fons de quadrícula vertical */}
                      <div className="absolute inset-0 flex justify-between px-4 pointer-events-none opacity-10">
                         {[...Array(11)].map((_, i) => <div key={i} className="h-full w-px bg-white"></div>)}
                      </div>

                      {/* RULER synced to Track Ref for correct width clicking */}
                      <div 
                        className="h-6 w-full bg-gray-800 border-b border-gray-700 relative cursor-pointer px-4 box-border shrink-0 z-10" 
                        onClick={handleTimelineClick}
                      >
                         <div className="absolute top-0 bottom-0 w-0.5 bg-red-500 z-10 pointer-events-none" style={{ left: `${(currentTime / duration) * 100}%`, marginLeft: '16px' }}></div>
                         <div className="absolute bottom-0 left-4 right-4 h-1 flex justify-between">
                             {[...Array(11)].map((_, i) => <div key={i} className="h-full w-px bg-gray-600"></div>)}
                         </div>
                      </div>

                      {/* TRACKS CONTAINER (Scrollable) */}
                      <div 
                        ref={timelineTrackRef}
                        className="flex-1 overflow-y-auto p-2 px-4 relative z-0"
                      >
                          <div className="absolute top-0 bottom-0 w-0.5 bg-red-500/20 pointer-events-none z-0" style={{ left: `${(currentTime / duration) * 100}%`}}></div>

                          {activeNode.options.map((opt, idx) => {
                              const leftPct = (opt.startTime / duration) * 100;
                              const widthPct = ((opt.endTime - opt.startTime) / duration) * 100;

                              return (
                                  <div key={opt.id} className="h-8 relative w-full bg-gray-800/50 rounded mb-1 border border-gray-700/50">
                                      <div className="absolute left-2 top-0 bottom-0 flex items-center text-[10px] text-gray-600 pointer-events-none z-0 w-32 truncate select-none">{opt.label}</div>
                                      
                                      <div 
                                        className="absolute top-1 bottom-1 bg-blue-600/60 border border-blue-400 rounded cursor-pointer group flex items-center justify-between px-1 hover:bg-blue-600/80 z-10"
                                        style={{ left: `${leftPct}%`, width: `${widthPct}%` }}
                                        onMouseDown={(e) => handleTimelineItemMouseDown(e, opt, 'timeline-move')}
                                      >
                                          {/* Left Resize Handle: shrink-0 is CRITICAL */}
                                          <div className="w-2 h-full bg-blue-400/30 cursor-w-resize hover:bg-white z-20 shrink-0" onMouseDown={(e) => handleTimelineItemMouseDown(e, opt, 'timeline-start')}></div>
                                          
                                          {/* Label: min-w-0 to allow shrinking */}
                                          <span className="text-[10px] text-white font-mono drop-shadow-md truncate pointer-events-none select-none px-1 min-w-0 flex-1 text-center">{opt.label}</span>
                                          
                                          {/* Right Resize Handle: shrink-0 is CRITICAL */}
                                          <div className="w-2 h-full bg-blue-400/30 cursor-e-resize hover:bg-white z-20 shrink-0" onMouseDown={(e) => handleTimelineItemMouseDown(e, opt, 'timeline-end')}></div>
                                      </div>
                                  </div>
                              );
                          })}
                          {activeNode.options.length === 0 && <div className="text-center text-xs text-gray-600 py-4">Afegeix opcions per veure les pistes.</div>}
                      </div>
                   </div>
                </div>
              )}
            </main>

            {mode === 'edit' && (
              <aside className="w-72 bg-gray-800 border-l border-gray-700 flex flex-col shrink-0 overflow-y-auto">
                <div className="p-4 border-b border-gray-700" style={{ borderTop: `4px solid ${activeNode.color || '#3b82f6'}` }}>
                  <h2 className="font-semibold text-gray-300 flex items-center gap-2"><Settings size={16} /> Propietats</h2>
                </div>
                <div className="p-4 space-y-4">
                  <div>
                    <label className="block text-xs font-medium text-gray-500 uppercase mb-1">Títol</label>
                    <input type="text" value={activeNode.title} onChange={(e) => updateNode(activeNode.id, 'title', e.target.value)} className="w-full bg-gray-900 border border-gray-600 rounded px-2 py-1 text-sm outline-none"/>
                  </div>
                  <div>
                    <label className="block text-xs font-medium text-gray-500 uppercase mb-1">Vídeo</label>
                    <input type="text" value={activeNode.videoUrl} onChange={(e) => updateNode(activeNode.id, 'videoUrl', e.target.value)} className="w-full bg-gray-900 border border-gray-600 rounded px-2 py-1 text-xs mb-2 font-mono"/>
                    <input type="file" ref={fileInputRef} onChange={handleFileUpload} accept="video/*" className="hidden" />
                    <button onClick={() => fileInputRef.current?.click()} className="w-full bg-gray-700 hover:bg-gray-600 text-xs py-1 rounded flex items-center justify-center gap-2 border border-gray-600"><Upload size={12} /> Pujar Local</button>
                  </div>
                  <div className="border-t border-gray-700 pt-4">
                    <div className="flex justify-between items-center mb-3"><h3 className="text-sm font-semibold text-gray-300">Botons</h3><button onClick={addOption} className="text-xs bg-blue-600 px-2 py-1 rounded text-white"><Plus size={12}/></button></div>
                    <div className="space-y-4">
                      {activeNode.options.map((opt, idx) => (
                        <div key={opt.id} className={`bg-gray-750 border rounded p-2 ${dragState.targetId === opt.id ? 'border-yellow-500' : 'border-gray-600'}`}>
                          <div className="flex justify-between items-center mb-2"><span className="text-xs font-bold text-gray-400">Botó #{idx + 1}</span><button onClick={() => removeOption(opt.id)} className="text-red-400"><Trash2 size={12}/></button></div>
                          <input type="text" value={opt.label} onChange={(e) => updateOption(opt.id, 'label', e.target.value)} className="bg-gray-900 border border-gray-600 rounded px-2 py-1 text-sm w-full mb-2"/>
                          <select value={opt.targetNodeId} onChange={(e) => updateOption(opt.id, 'targetNodeId', e.target.value)} className="bg-gray-900 border border-gray-600 rounded px-2 py-1 text-sm w-full mb-2">{nodes.map(n => <option key={n.id} value={n.id}>➔ {n.title}</option>)}</select>
                          
                          <div className="flex gap-2 mb-2">
                             <div className="flex-1"><label className="text-[10px] text-gray-500">Inici</label><input type="number" step="0.5" value={opt.startTime} onChange={(e) => updateOption(opt.id, 'startTime', parseFloat(e.target.value))} className="w-full bg-gray-900 border border-gray-600 text-xs px-1 rounded"/></div>
                             <div className="flex-1"><label className="text-[10px] text-gray-500">Fi</label><input type="number" step="0.5" value={opt.endTime || duration} onChange={(e) => updateOption(opt.id, 'endTime', parseFloat(e.target.value))} className="w-full bg-gray-900 border border-gray-600 text-xs px-1 rounded"/></div>
                          </div>

                          <details>
                             <summary className="text-xs text-blue-400 cursor-pointer flex justify-between items-center group">
                                Estil 
                                <div className="flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                                    <button 
                                        onClick={(e) => { e.preventDefault(); handleCopyStyle(opt.style); }} 
                                        className="p-1 hover:bg-gray-600 rounded text-gray-300" 
                                        title="Copiar Estil"
                                    >
                                        <Copy size={12}/>
                                    </button>
                                    {clipboardStyle && (
                                        <button 
                                            onClick={(e) => { e.preventDefault(); handlePasteStyle(opt.id); }} 
                                            className="p-1 hover:bg-gray-600 rounded text-green-300" 
                                            title="Enganxar Estil"
                                        >
                                            <Clipboard size={12}/>
                                        </button>
                                    )}
                                </div>
                             </summary>
                             <div className="mt-2 space-y-2">
                                <div className="grid grid-cols-2 gap-2">
                                    <input type="number" placeholder="W" value={parseFloat(opt.style.width)} onChange={(e) => updateOptionStyle(opt.id, 'width', parseFloat(e.target.value))} className="bg-gray-900 border border-gray-600 text-xs px-1 rounded"/>
                                    <input type="number" placeholder="H" value={parseFloat(opt.style.height)} onChange={(e) => updateOptionStyle(opt.id, 'height', parseFloat(e.target.value))} className="bg-gray-900 border border-gray-600 text-xs px-1 rounded"/>
                                </div>
                                
                                <div>
                                    <label className="text-[10px] text-gray-500 block">Fons (Color i Opacitat)</label>
                                    <div className="flex gap-2 items-center">
                                        <input type="color" value={opt.style.backgroundColor} onChange={(e) => updateOptionStyle(opt.id, 'backgroundColor', e.target.value)} className="h-6 w-8 rounded cursor-pointer border-none"/>
                                        <input 
                                            type="range" min="0" max="1" step="0.1" 
                                            value={opt.style.bgOpacity !== undefined ? opt.style.bgOpacity : 1} 
                                            onChange={(e) => updateOptionStyle(opt.id, 'bgOpacity', parseFloat(e.target.value))}
                                            className="flex-1 accent-blue-500 h-1 bg-gray-600"
                                            title={`Opacitat: ${opt.style.bgOpacity || 1}`}
                                        />
                                    </div>
                                </div>

                                <div>
                                    <label className="text-[10px] text-gray-500 block">Text</label>
                                    <input type="color" value={opt.style.color} onChange={(e) => updateOptionStyle(opt.id, 'color', e.target.value)} className="w-full h-6 rounded cursor-pointer border-none"/>
                                </div>
                             </div>
                          </details>
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              </aside>
            )}
          </>
        )}
      </div>
    </div>
  );
}
